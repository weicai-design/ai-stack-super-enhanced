<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Stack æ™ºèƒ½å¯¹è¯ä¸­å¿ƒ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .chat-container {
            width: 90%;
            max-width: 1200px;
            height: 90vh;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }
        
        .memory-info {
            font-size: 12px;
            opacity: 0.9;
            padding: 5px 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            cursor: pointer;
        }
        
        .memory-info:hover {
            background: rgba(255,255,255,0.3);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* æé†’æŒ‰é’®åŠ¨ç”» */
        .reminder-badge {
            position: relative;
        }
        
        .reminder-badge::after {
            content: attr(data-count);
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ff4444;
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: bold;
            animation: bounce 0.5s;
        }
        
        @keyframes bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        /* å¯¹è¯å†å²æ—¶é—´çº¿æ ·å¼ */
        .timeline {
            position: relative;
            padding: 20px 0;
        }
        
        .timeline-item {
            position: relative;
            padding-left: 40px;
            padding-bottom: 30px;
        }
        
        .timeline-item::before {
            content: '';
            position: absolute;
            left: 12px;
            top: 0;
            bottom: -30px;
            width: 2px;
            background: #e0e0e0;
        }
        
        .timeline-item:last-child::before {
            display: none;
        }
        
        .timeline-dot {
            position: absolute;
            left: 0;
            top: 5px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #667eea;
            border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .timeline-content {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .chat-messages {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            background: #f8fafc;
        }

        .message {
            margin-bottom: 20px;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message-user {
            display: flex;
            justify-content: flex-end;
        }

        .message-ai {
            display: flex;
            justify-content: flex-start;
        }

        .message-content {
            max-width: 70%;
            padding: 15px 20px;
            border-radius: 15px;
            line-height: 1.6;
        }

        .message-user .message-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .message-ai .message-content {
            background: white;
            color: #1e293b;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .message-meta {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 5px;
        }

        .message-ai .message-content pre {
            background: #f1f5f9;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            overflow-x: auto;
        }
        
        /* TTSæœ—è¯»æŒ‰é’® */
        .tts-btn {
            display: inline-block;
            margin-top: 10px;
            padding: 6px 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }
        
        .tts-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .tts-btn.playing {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .thinking-indicator {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 15px 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 200px;
        }

        .thinking-indicator.active {
            display: flex;
        }

        .typing-dots {
            display: flex;
            gap: 5px;
        }

        .typing-dots span {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #667eea;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
        .typing-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        .chat-input-area {
            padding: 20px 30px;
            background: white;
            border-top: 1px solid #e2e8f0;
        }

        .model-selector-area {
            padding: 10px 0;
            border-bottom: 1px solid #e2e8f0;
            margin-bottom: 10px;
        }

        .model-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .model-selector label {
            font-size: 14px;
            font-weight: 500;
            color: #475569;
        }

        #modelSelect {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            flex: 1;
            max-width: 300px;
        }

        #modelSelect:hover {
            border-color: #667eea;
        }

        #modelSelect:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .input-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            align-items: center;
        }

        .control-btn {
            padding: 8px 15px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .control-btn:hover {
            background: #e2e8f0;
        }

        .control-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .input-wrapper {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        #fileInput {
            display: none;
        }

        .file-preview {
            padding: 10px;
            background: #f1f5f9;
            border-radius: 8px;
            margin-bottom: 10px;
            font-size: 13px;
        }

        #userInput {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 25px;
            font-size: 15px;
            resize: none;
            max-height: 150px;
            font-family: inherit;
        }

        #userInput:focus {
            outline: none;
            border-color: #667eea;
        }

        #sendBtn {
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #sendBtn:hover {
            transform: scale(1.05);
        }

        #sendBtn:active {
            transform: scale(0.95);
        }

        #sendBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .quick-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .quick-btn {
            padding: 8px 15px;
            background: #f1f5f9;
            border: 1px solid #e2e8f0;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quick-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .system-status {
            padding: 10px 15px;
            background: #f0fdf4;
            border: 1px solid #86efac;
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 13px;
            color: #166534;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            background: #dbeafe;
            color: #1e40af;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <div>
                <h1>ğŸ¤– AI Stack æ™ºèƒ½å¯¹è¯ä¸­å¿ƒ</h1>
                <div style="font-size: 14px; opacity: 0.9; margin-top: 5px;">
                    ä¼ä¸šçº§AIç³»ç»Ÿ Â· æ™ºèƒ½è·¯ç”± Â· RAGéªŒè¯ Â· è‡ªæˆ‘å­¦ä¹ 
                </div>
            </div>
            <div class="status-indicator">
                <div class="status-dot"></div>
                <span id="statusText">ç³»ç»Ÿå°±ç»ª</span>
                <span id="memoryInfo" class="memory-info" onclick="showMemoryStats()" title="ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…">ğŸ’¾ è®°å¿†: 0/100ä¸‡å­—</span>
                <button class="quick-btn" onclick="showExportMenu()" title="å¯¼å‡ºå¯¹è¯å†å²" style="margin-left: 10px;">ğŸ“¤ å¯¼å‡º</button>
                <button class="quick-btn" id="reminderBtn" onclick="showReminders()" title="æŸ¥çœ‹æé†’" style="margin-left: 5px;">ğŸ”” æé†’</button>
            </div>
        </div>

        <div class="chat-messages" id="chatMessages">
            <div class="system-status">
                ğŸŠ æ¬¢è¿ä½¿ç”¨AI Stackæ™ºèƒ½å¯¹è¯ä¸­å¿ƒï¼
                <span class="badge">RAGå¢å¼º</span>
                <span class="badge">å·®å¼‚æ£€æµ‹</span>
                <span class="badge">è‡ªæˆ‘å­¦ä¹ </span>
            </div>
        </div>

        <div class="chat-input-area">
            <div class="quick-actions">
                <button class="quick-btn" onclick="quickAsk('ä»Šå¤©çš„è´¢åŠ¡æ•°æ®')">ğŸ“Š è´¢åŠ¡æ•°æ®</button>
                <button class="quick-btn" onclick="quickAsk('è´µå·èŒ…å°è‚¡ä»·')">ğŸ“ˆ èŒ…å°è‚¡ä»·</button>
                <button class="quick-btn" onclick="quickAsk('ä»€ä¹ˆæ˜¯æœºå™¨å­¦ä¹ ')">ğŸ“š çŸ¥è¯†æœç´¢</button>
                <button class="quick-btn" onclick="quickAsk('æœç´¢ äººå·¥æ™ºèƒ½æœ€æ–°è¿›å±•')">ğŸ” ç½‘é¡µæœç´¢</button>
            </div>

            <!-- éœ€æ±‚8: æ¨¡å‹é€‰æ‹©å™¨ -->
            <div class="model-selector-area">
                <div class="model-selector">
                    <label for="modelSelect">ğŸ¤– AIæ¨¡å‹ï¼š</label>
                    <select id="modelSelect" onchange="updateModelInfo()">
                        <option value="qwen2.5:7b">Qwen 2.5 (æ¨è) - 7B é€šç”¨</option>
                        <option value="qwen2.5:1.5b">Qwen 2.5 è½»é‡ç‰ˆ - 1.5B é€šç”¨</option>
                        <option value="llama3.2:1b">Llama 3.2 - 1B é€šç”¨</option>
                        <option value="mistral:7b">Mistral - 7B é€šç”¨</option>
                        <option value="llama2:7b">Llama 2 - 7B é€šç”¨</option>
                        <option value="qwen:7b">Qwen 1.0 - 7B é€šç”¨</option>
                    </select>
                    <span id="modelInfo" style="font-size: 12px; color: #64748b;"></span>
                </div>
            </div>
            
            <div class="input-controls">
                <button class="control-btn" id="fileBtn" onclick="document.getElementById('fileInput').click()">
                    ğŸ“ ä¸Šä¼ æ–‡ä»¶
                </button>
                <button class="control-btn" id="voiceBtn" onclick="toggleVoice()">
                    ğŸ¤ è¯­éŸ³è¾“å…¥
                </button>
                <button class="control-btn" id="webSearchBtn" onclick="toggleWebSearch()">
                    ğŸŒ ç½‘é¡µæœç´¢
                </button>
                <input type="file" id="fileInput" onchange="handleFileUpload()" accept="*/*">
                <span id="uploadStatus" style="font-size: 12px; color: #64748b;"></span>
            </div>
            
            <div id="filePreview" class="file-preview" style="display: none;"></div>
            
            <div class="input-wrapper">
                <textarea id="userInput" placeholder="è¾“å…¥ä½ çš„é—®é¢˜... (æ”¯æŒæ‰€æœ‰AI StackåŠŸèƒ½ã€æ–‡ä»¶ä¸Šä¼ ã€è¯­éŸ³è¾“å…¥)" rows="1"></textarea>
                <button id="sendBtn" onclick="sendMessage()">å‘é€</button>
            </div>
        </div>
    </div>

    <script>
        const chatMessages = document.getElementById('chatMessages');
        const userInput = document.getElementById('userInput');
        const sendBtn = document.getElementById('sendBtn');
        const statusText = document.getElementById('statusText');
        const modelSelect = document.getElementById('modelSelect');
        
        let webSearchEnabled = false;
        let voiceRecording = false;
        let currentFile = null;
        let availableModels = [];
        let currentSessionId = null;  // å½“å‰ä¼šè¯IDï¼ˆ100ä¸‡å­—è®°å¿†ï¼‰
        let userId = 'user_001';  // ç”¨æˆ·ID

        // è‡ªåŠ¨è°ƒæ•´è¾“å…¥æ¡†é«˜åº¦
        userInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = this.scrollHeight + 'px';
        });

        // å›è½¦å‘é€
        userInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // å¿«æ·æé—®
        function quickAsk(question) {
            userInput.value = question;
            sendMessage();
        }

        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©åŒº
        function addMessage(content, isUser) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'message-user' : 'message-ai'}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.innerHTML = formatMessage(content);
            
            const metaDiv = document.createElement('div');
            metaDiv.className = 'message-meta';
            metaDiv.textContent = new Date().toLocaleTimeString('zh-CN');
            contentDiv.appendChild(metaDiv);
            
            // AIå›å¤æ·»åŠ æœ—è¯»æŒ‰é’®
            if (!isUser && content.length > 0 && content.length < 1000) {
                const ttsBtn = document.createElement('button');
                ttsBtn.className = 'tts-btn';
                ttsBtn.innerHTML = 'ğŸ”Š æœ—è¯»';
                ttsBtn.onclick = () => playTTS(content, ttsBtn);
                contentDiv.appendChild(ttsBtn);
            }
            
            messageDiv.appendChild(contentDiv);
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // å½»åº•ä¿®å¤TTSæ··éŸ³é—®é¢˜
        let currentSpeech = null;
        let currentButton = null;
        let isSpeaking = false;  // å…¨å±€é”
        
        async function playTTS(text, button) {
            // 1. å¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œå¼ºåˆ¶å…¨éƒ¨åœæ­¢
            if (isSpeaking || window.speechSynthesis.speaking || window.speechSynthesis.pending) {
                console.log('â¹ï¸ åœæ­¢ä¹‹å‰çš„æ’­æ”¾');
                window.speechSynthesis.cancel();
                
                // é‡ç½®æ‰€æœ‰æŒ‰é’®çŠ¶æ€
                document.querySelectorAll('.tts-btn').forEach(btn => {
                    btn.classList.remove('playing');
                    btn.innerHTML = 'ğŸ”Š æœ—è¯»';
                    btn.disabled = false;
                });
                
                currentSpeech = null;
                currentButton = null;
                isSpeaking = false;
                
                // å¦‚æœç‚¹å‡»çš„æ˜¯åŒä¸€ä¸ªæŒ‰é’®ï¼Œåªåœæ­¢ä¸é‡æ–°æ’­æ”¾
                if (button.classList.contains('playing')) {
                    return;
                }
                
                // ç­‰å¾…cancelå®Œå…¨ç”Ÿæ•ˆ
                await new Promise(resolve => setTimeout(resolve, 300));
            }
            
            // 2. ç¡®ä¿æ²¡æœ‰ä»»ä½•æ®‹ç•™
            window.speechSynthesis.cancel();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
                button.innerHTML = 'ğŸ”„ å‡†å¤‡ä¸­...';
                button.disabled = true;
                
                // è°ƒç”¨åç«¯æ¸…ç†æ–‡æœ¬
                const response = await fetch(`/api/voice/tts/webui?text=${encodeURIComponent(text)}&voice=zh-CN&rate=1.0&pitch=1.0`, {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.success && data.text) {
                    // 3. è®¾ç½®å…¨å±€é”
                    isSpeaking = true;
                    
                    // 4. åˆ›å»ºutterance
                    const utterance = new SpeechSynthesisUtterance(data.text);
                    
                    // 5. é€‰æ‹©é«˜è´¨é‡è¯­éŸ³
                    const voices = window.speechSynthesis.getVoices();
                    const zhVoice = voices.find(v => v.name.includes('Tingting')) ||
                                   voices.find(v => v.name.includes('Yaoyao')) ||
                                   voices.find(v => v.name.includes('Sinji')) ||
                                   voices.find(v => v.lang === 'zh-CN') ||
                                   voices.find(v => v.lang.startsWith('zh')) ||
                                   voices[0];
                    
                    if (zhVoice) {
                        utterance.voice = zhVoice;
                        console.log('ğŸ”Š ä½¿ç”¨è¯­éŸ³:', zhVoice.name);
                    }
                    
                    // 6. ä¼˜åŒ–å‚æ•°ï¼ˆé¿å…æ··éŸ³ï¼‰
                    utterance.lang = 'zh-CN';
                    utterance.rate = 0.95;    // ç¨æ…¢ï¼Œé¿å…é‡å 
                    utterance.pitch = 1.0;    // æ ‡å‡†éŸ³è°ƒ
                    utterance.volume = 1.0;   // æœ€å¤§éŸ³é‡
                    
                    // 7. æ›´æ–°æŒ‰é’®çŠ¶æ€
                    button.classList.add('playing');
                    button.innerHTML = 'â¸ï¸ åœæ­¢';
                    button.disabled = false;
                    currentButton = button;
                    currentSpeech = utterance;
                    
                    // 8. äº‹ä»¶å¤„ç†
                    utterance.onstart = () => {
                        isSpeaking = true;
                        console.log('âœ… æ’­æ”¾å¼€å§‹:', data.text.substring(0, 30) + '...');
                    };
                    
                    utterance.onend = () => {
                        console.log('âœ… æ’­æ”¾å®Œæˆ');
                        isSpeaking = false;
                        if (currentButton) {
                            currentButton.classList.remove('playing');
                            currentButton.innerHTML = 'ğŸ”Š æœ—è¯»';
                            currentButton.disabled = false;
                        }
                        currentSpeech = null;
                        currentButton = null;
                    };
                    
                    utterance.onerror = (e) => {
                        console.error('âŒ æ’­æ”¾é”™è¯¯:', e.error);
                        isSpeaking = false;
                        if (currentButton) {
                            currentButton.classList.remove('playing');
                            currentButton.innerHTML = 'ğŸ”Š æœ—è¯»';
                            currentButton.disabled = false;
                        }
                        currentSpeech = null;
                        currentButton = null;
                    };
                    
                    // 9. ç¡®ä¿å®Œå…¨é™éŸ³åå†æ’­æ”¾
                    window.speechSynthesis.cancel();
                    
                    // 10. å»¶è¿Ÿæ’­æ”¾ï¼Œç¡®ä¿æ²¡æœ‰æ··éŸ³
                    setTimeout(() => {
                        // å†æ¬¡æ£€æŸ¥ï¼Œç¡®ä¿æ²¡æœ‰å…¶ä»–åœ¨æ’­æ”¾
                        if (window.speechSynthesis.speaking) {
                            window.speechSynthesis.cancel();
                        }
                        
                        // æ¢å¤ä»»ä½•æš‚åœçŠ¶æ€
                        window.speechSynthesis.resume();
                        
                        // æ’­æ”¾
                        window.speechSynthesis.speak(utterance);
                        console.log('ğŸµ å·²åŠ å…¥æ’­æ”¾é˜Ÿåˆ—');
                    }, 200);  // å»¶è¿Ÿ200msç¡®ä¿å®Œå…¨æ¸…ç©º
                    
                } else {
                    button.innerHTML = 'âŒ ä¸å¯ç”¨';
                    button.disabled = false;
                }
            } catch (error) {
                console.error('TTSé”™è¯¯:', error);
                button.innerHTML = 'âŒ å¤±è´¥';
                button.disabled = false;
            }
        }
        
        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–è¯­éŸ³åˆ—è¡¨
        window.addEventListener('DOMContentLoaded', () => {
            // åŠ è½½è¯­éŸ³åˆ—è¡¨
            if (window.speechSynthesis) {
                // è§¦å‘è¯­éŸ³åˆ—è¡¨åŠ è½½
                window.speechSynthesis.getVoices();
                
                window.speechSynthesis.onvoiceschanged = () => {
                    const voices = window.speechSynthesis.getVoices();
                    console.log('ğŸ“¢ å¯ç”¨è¯­éŸ³æ€»æ•°:', voices.length);
                    
                    const zhVoices = voices.filter(v => v.lang.startsWith('zh'));
                    console.log('ğŸ‡¨ğŸ‡³ ä¸­æ–‡è¯­éŸ³æ•°é‡:', zhVoices.length);
                    console.log('ğŸ¤ ä¸­æ–‡è¯­éŸ³åˆ—è¡¨:', zhVoices.map(v => `${v.name} (${v.lang})`));
                    
                    // æ˜¾ç¤ºæ¨èè¯­éŸ³
                    const tingting = voices.find(v => v.name.includes('Tingting'));
                    if (tingting) {
                        console.log('â­ æ¨èä½¿ç”¨:', tingting.name, 'ï¼ˆæœ€æ¸…æ™°ï¼‰');
                    }
                };
            }
            
            // Web Speech Recognitionåˆå§‹åŒ–æ£€æŸ¥
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                console.log('âœ… Web Speech Recognition å¯ç”¨');
            } else {
                console.warn('âš ï¸ æµè§ˆå™¨ä¸æ”¯æŒWeb Speech Recognition');
                console.warn('   è¯·ä½¿ç”¨Chromeã€Edgeæˆ–Safari');
            }
        });

        // æ˜¾ç¤ºæ€è€ƒæŒ‡ç¤ºå™¨
        function showThinking(message = "AI Stackæ™ºèƒ½åˆ†æä¸­...") {
            const thinkingDiv = document.createElement('div');
            thinkingDiv.className = 'message message-ai';
            thinkingDiv.id = 'thinking-indicator';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'thinking-indicator active';
            contentDiv.innerHTML = `
                <div class="typing-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
                <span>${message}</span>
            `;
            
            thinkingDiv.appendChild(contentDiv);
            chatMessages.appendChild(thinkingDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function hideThinking() {
            const thinking = document.getElementById('thinking-indicator');
            if (thinking) thinking.remove();
        }

        // æ ¼å¼åŒ–æ¶ˆæ¯
        function formatMessage(content) {
            // å¤„ç†ã€æ ‡é¢˜ã€‘æ ¼å¼
            content = content.replace(/ã€([^ã€‘]+)ã€‘/g, '<strong style="color: #667eea;">ã€$1ã€‘</strong>');
            
            // å¤„ç†æ¢è¡Œ
            content = content.replace(/\n/g, '<br>');
            
            // å¤„ç†ä»£ç å—
            content = content.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
            
            return content;
        }

        // å‘é€æ¶ˆæ¯
        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) return;

            // ç¦ç”¨è¾“å…¥
            sendBtn.disabled = true;
            userInput.disabled = true;

            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
            addMessage(message, true);
            userInput.value = '';
            userInput.style.height = 'auto';

            // æ˜¾ç¤ºæ€è€ƒä¸­
            showThinking();
            updateStatus("ğŸ§  AI Stackæ™ºèƒ½åˆ†æä¸­...");

            try {
                // è°ƒç”¨åç«¯API
                // è·å–é€‰ä¸­çš„æ¨¡å‹
                const selectedModel = modelSelect.value;
                
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: message,
                        user_id: userId,
                        session_id: currentSessionId,  // ä¼ é€’ä¼šè¯ID
                        model: selectedModel,
                        web_search: webSearchEnabled
                    })
                });

                const data = await response.json();
                
                // éšè—æ€è€ƒæŒ‡ç¤ºå™¨
                hideThinking();

                // æ·»åŠ AIå›å¤
                if (data.success) {
                    addMessage(data.response, false);
                    
                    // æ›´æ–°ä¼šè¯ID
                    if (data.session_id) {
                        currentSessionId = data.session_id;
                    }
                    
                    // æ˜¾ç¤ºç³»ç»ŸçŠ¶æ€
                    if (data.metadata) {
                        updateStatus(`âœ… ${data.metadata.detected_system || 'å®Œæˆ'} | å­¦ä¹ æ¬¡æ•°: ${data.metadata.learning_count || 0}`);
                        
                        // æ›´æ–°è®°å¿†ä¿¡æ¯
                        if (data.metadata.context_stats) {
                            updateMemoryInfo(data.metadata.context_stats);
                        }
                    }
                } else {
                    addMessage(`âŒ é”™è¯¯: ${data.error}`, false);
                    updateStatus("âŒ å¤„ç†å¤±è´¥");
                }

            } catch (error) {
                hideThinking();
                addMessage(`âŒ ç½‘ç»œé”™è¯¯: ${error.message}`, false);
                updateStatus("âŒ è¿æ¥å¤±è´¥");
            }

            // æ¢å¤è¾“å…¥
            sendBtn.disabled = false;
            userInput.disabled = false;
            userInput.focus();
        }

        function updateStatus(text) {
            statusText.textContent = text;
        }
        
        // æ›´æ–°è®°å¿†ä¿¡æ¯æ˜¾ç¤º
        function updateMemoryInfo(stats) {
            const memoryInfo = document.getElementById('memoryInfo');
            if (memoryInfo && stats) {
                const words = stats.total_words || 0;
                const percentage = stats.usage_percentage || 0;
                memoryInfo.textContent = `ğŸ’¾ è®°å¿†: ${words.toLocaleString()}/100ä¸‡å­— (${percentage.toFixed(1)}%)`;
            }
        }
        
        // æ˜¾ç¤ºå¯¼å‡ºèœå•
        function showExportMenu() {
            if (!currentSessionId) {
                alert('å½“å‰æ²¡æœ‰æ´»åŠ¨ä¼šè¯');
                return;
            }
            
            const formats = [
                {name: 'Markdown (.md)', url: `/api/export/${currentSessionId}/markdown`},
                {name: 'HTML (.html)', url: `/api/export/${currentSessionId}/html`},
                {name: 'JSON (.json)', url: `/api/export/${currentSessionId}/json`},
                {name: 'TXT (.txt)', url: `/api/export/${currentSessionId}/txt`}
            ];
            
            let message = 'ğŸ“¤ é€‰æ‹©å¯¼å‡ºæ ¼å¼:\\n\\n';
            formats.forEach((fmt, idx) => {
                message += `${idx + 1}. ${fmt.name}\\n`;
            });
            
            const choice = prompt(message + '\\nè¯·è¾“å…¥åºå·(1-4):');
            
            if (choice && choice >= '1' && choice <= '4') {
                const format = formats[parseInt(choice) - 1];
                window.open(format.url, '_blank');
                updateStatus(`ğŸ“¥ æ­£åœ¨å¯¼å‡ºä¸º ${format.name}...`);
            }
        }
        
        // æ˜¾ç¤ºæé†’åˆ—è¡¨
        async function showReminders() {
            try {
                const response = await fetch(`/api/reminder/active/${userId}`);
                const data = await response.json();
                
                if (data.success && data.reminders && data.reminders.length > 0) {
                    let message = `ğŸ”” æ‚¨æœ‰ ${data.count} ä¸ªæé†’:\\n\\n`;
                    
                    data.reminders.forEach((reminder, idx) => {
                        const priority = 'â­'.repeat(reminder.priority);
                        const type = reminder.reminder_type === 'event' ? 'ğŸ“…' : 
                                   reminder.reminder_type === 'task' ? 'âœ…' : 'ğŸ’¡';
                        const dueTime = reminder.due_time ? new Date(reminder.due_time).toLocaleString() : 'æœªè®¾ç½®';
                        
                        message += `${idx + 1}. ${type} ${priority}\\n`;
                        message += `   ${reminder.content}\\n`;
                        message += `   åˆ°æœŸ: ${dueTime}\\n\\n`;
                    });
                    
                    alert(message);
                } else {
                    alert('ğŸ‰ æš‚æ— å¾…å¤„ç†æé†’');
                }
            } catch (error) {
                console.error('è·å–æé†’å¤±è´¥:', error);
                alert('è·å–æé†’å¤±è´¥');
            }
        }
        
        // æ£€æŸ¥åˆ°æœŸæé†’ï¼ˆå®šæ—¶æ£€æŸ¥ï¼‰
        async function checkDueReminders() {
            try {
                const response = await fetch(`/api/reminder/due/${userId}`);
                const data = await response.json();
                
                if (data.success && data.reminders && data.reminders.length > 0) {
                    // æ›´æ–°æé†’æŒ‰é’®å¾½ç« 
                    const reminderBtn = document.getElementById('reminderBtn');
                    if (reminderBtn) {
                        reminderBtn.classList.add('reminder-badge');
                        reminderBtn.setAttribute('data-count', data.count);
                    }
                    
                    // æ˜¾ç¤ºç¬¬ä¸€ä¸ªåˆ°æœŸæé†’
                    const reminder = data.reminders[0];
                    const showAlert = confirm(
                        `ğŸ”” æé†’åˆ°æœŸï¼\\n\\n${reminder.content}\\n\\næ˜¯å¦æ ‡è®°ä¸ºå·²å®Œæˆï¼Ÿ`
                    );
                    
                    if (showAlert) {
                        await fetch(`/api/reminder/${reminder.id}/complete`, {method: 'POST'});
                        checkDueReminders(); // åˆ·æ–°
                    }
                }
            } catch (error) {
                console.error('æ£€æŸ¥æé†’å¤±è´¥:', error);
            }
        }
        
        // æ˜¾ç¤ºè®°å¿†ç»Ÿè®¡è¯¦æƒ…
        async function showMemoryStats() {
            if (!currentSessionId) {
                alert('å½“å‰æ²¡æœ‰æ´»åŠ¨ä¼šè¯');
                return;
            }
            
            try {
                const response = await fetch(`/api/context/stats/${currentSessionId}`);
                const data = await response.json();
                
                if (data.success && data.stats) {
                    const stats = data.stats;
                    alert(`ğŸ“Š ä¼šè¯è®°å¿†ç»Ÿè®¡\\n\\n` +
                          `ğŸ’¬ æ¶ˆæ¯æ€»æ•°: ${stats.total_messages}æ¡\\n` +
                          `ğŸ“ æ€»å­—æ•°: ${stats.total_words.toLocaleString()}å­—\\n` +
                          `ğŸ’¾ å­˜å‚¨å¤§å°: ${stats.capacity_used_mb} MB\\n` +
                          `ğŸ“ˆ å®¹é‡ä½¿ç”¨: ${stats.estimated_capacity}\\n` +
                          `âš¡ ä½¿ç”¨ç‡: ${stats.usage_percentage}%`);
                } else {
                    alert('æš‚æ— è®°å¿†ç»Ÿè®¡æ•°æ®');
                }
            } catch (error) {
                console.error('è·å–è®°å¿†ç»Ÿè®¡å¤±è´¥:', error);
                alert('è·å–è®°å¿†ç»Ÿè®¡å¤±è´¥');
            }
        }

        // åˆ‡æ¢ç½‘é¡µæœç´¢
        function toggleWebSearch() {
            webSearchEnabled = !webSearchEnabled;
            const btn = document.getElementById('webSearchBtn');
            if (webSearchEnabled) {
                btn.classList.add('active');
                updateStatus("ğŸŒ ç½‘é¡µæœç´¢å·²å¯ç”¨");
            } else {
                btn.classList.remove('active');
                updateStatus("ç³»ç»Ÿå°±ç»ª");
            }
        }

        // åˆ‡æ¢è¯­éŸ³è¾“å…¥
        // Open WebUIé£æ ¼çš„Web Speech Recognition
        let recognition = null;
        let recognizing = false;
        
        // åˆå§‹åŒ–Web Speech API
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.lang = 'zh-CN';
            recognition.continuous = false;
            recognition.interimResults = true;
            
            recognition.onstart = () => {
                console.log('âœ… è¯­éŸ³è¯†åˆ«å·²å¯åŠ¨');
            };
            
            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    const confidence = event.results[i][0].confidence;
                    
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                        console.log(`âœ… æœ€ç»ˆè¯†åˆ«: "${transcript}" (ç½®ä¿¡åº¦: ${(confidence * 100).toFixed(1)}%)`);
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                // å®æ—¶æ˜¾ç¤º
                if (finalTranscript) {
                    // æœ€ç»ˆç»“æœï¼šè¿½åŠ åˆ°è¾“å…¥æ¡†
                    userInput.value += finalTranscript;
                    updateStatus('âœ… è¯†åˆ«å®Œæˆï¼š' + finalTranscript);
                    
                    // æ˜¾ç¤ºåœ¨ç•Œé¢ä¸Š
                    const voiceIndicator = document.getElementById('voiceIndicator');
                    if (voiceIndicator) {
                        voiceIndicator.textContent = `âœ… è¯†åˆ«åˆ°ï¼š${finalTranscript}`;
                        voiceIndicator.style.color = '#4CAF50';
                    }
                } else if (interimTranscript) {
                    // ä¸´æ—¶ç»“æœï¼šæ˜¾ç¤ºåœ¨çŠ¶æ€æ 
                    updateStatus(`ğŸ¤ è¯†åˆ«ä¸­: ${interimTranscript}`);
                    
                    // æ˜¾ç¤ºåœ¨ç•Œé¢ä¸Š
                    const voiceIndicator = document.getElementById('voiceIndicator');
                    if (voiceIndicator) {
                        voiceIndicator.textContent = `ğŸ¤ ${interimTranscript}`;
                        voiceIndicator.style.color = '#FF9800';
                    }
                }
            };
            
            recognition.onerror = (event) => {
                console.error('è¯†åˆ«é”™è¯¯:', event.error);
                recognizing = false;
                const btn = document.getElementById('voiceBtn');
                if (btn) {
                    btn.classList.remove('active');
                    btn.innerHTML = 'ğŸ¤ è¯­éŸ³è¾“å…¥';
                }
                updateStatus('âŒ è¯­éŸ³è¯†åˆ«å¤±è´¥');
            };
            
            recognition.onend = () => {
                recognizing = false;
                const btn = document.getElementById('voiceBtn');
                if (btn) {
                    btn.classList.remove('active');
                    btn.innerHTML = 'ğŸ¤ è¯­éŸ³è¾“å…¥';
                }
            };
        }
        
        function toggleVoice() {
            const btn = document.getElementById('voiceBtn');
            const indicator = document.getElementById('voiceIndicator');
            
            if (!recognition) {
                alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«\n\nâœ… æ”¯æŒçš„æµè§ˆå™¨ï¼š\n- Chromeï¼ˆæ¨èï¼‰\n- Edge\n- Safari\n\nâŒ ä¸æ”¯æŒï¼š\n- Firefox');
                return;
            }
            
            if (recognizing) {
                // åœæ­¢è¯†åˆ«
                recognition.stop();
                recognizing = false;
                btn.classList.remove('active');
                btn.innerHTML = 'ğŸ¤ è¯­éŸ³è¾“å…¥';
                indicator.textContent = '';
                updateStatus("âœ… è¯­éŸ³è¯†åˆ«å·²åœæ­¢");
                console.log('â¹ï¸ åœæ­¢è¯­éŸ³è¯†åˆ«');
            } else {
                // å¼€å§‹è¯†åˆ«
                try {
                    // æ¸…ç©ºä¹‹å‰çš„å†…å®¹
                    userInput.value = '';
                    indicator.textContent = 'ğŸ¤ å‡†å¤‡ä¸­...';
                    
                    recognition.start();
                    recognizing = true;
                    btn.classList.add('active');
                    btn.innerHTML = 'ğŸ”´ æ­£åœ¨ç›‘å¬...';
                    updateStatus("ğŸ¤ è¯·å¼€å§‹è¯´è¯ï¼ˆWhisperå®æ—¶è¯†åˆ«ï¼‰");
                    console.log('â–¶ï¸ å¼€å§‹è¯­éŸ³è¯†åˆ«ï¼ˆæ•ˆæœå¥½çš„Whisperæ–¹å¼ï¼‰');
                } catch (error) {
                    console.error('âŒ å¯åŠ¨å¤±è´¥:', error);
                    recognizing = false;
                    btn.classList.remove('active');
                    btn.innerHTML = 'ğŸ¤ è¯­éŸ³è¾“å…¥';
                    indicator.textContent = '';
                    
                    if (error.message.includes('already started')) {
                        // å¦‚æœå·²ç»åœ¨è¿è¡Œï¼Œå…ˆåœæ­¢å†é‡å¯
                        recognition.stop();
                        setTimeout(() => toggleVoice(), 500);
                    } else {
                        alert('è¯­éŸ³è¯†åˆ«å¯åŠ¨å¤±è´¥\n\n' + error.message);
                    }
                }
            }
        }

        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        async function handleFileUpload() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) return;
            
            currentFile = file;
            const uploadStatus = document.getElementById('uploadStatus');
            const filePreview = document.getElementById('filePreview');
            
            uploadStatus.textContent = `ğŸ“ å·²é€‰æ‹©: ${file.name}`;
            filePreview.style.display = 'block';
            filePreview.innerHTML = `ğŸ“„ <strong>${file.name}</strong> (${(file.size / 1024).toFixed(2)} KB) - ç‚¹å‡»å‘é€æŒ‰é’®å¤„ç†`;
            
            // ä¸Šä¼ æ–‡ä»¶åˆ°æœåŠ¡å™¨
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                updateStatus("ğŸ“¤ æ­£åœ¨ä¸Šä¼ æ–‡ä»¶...");
                const response = await fetch('/api/file/upload', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.success) {
                    filePreview.innerHTML += `<br>âœ… æ–‡ä»¶å·²ä¸Šä¼ å¹¶å¤„ç†`;
                    if (result.rag_saved) {
                        filePreview.innerHTML += ` | å·²ä¿å­˜åˆ°RAGçŸ¥è¯†åº“`;
                    }
                    
                    // è‡ªåŠ¨åœ¨èŠå¤©æ¡†æ˜¾ç¤ºæ–‡ä»¶å†…å®¹
                    if (result.type === 'text') {
                        userInput.value = `æˆ‘ä¸Šä¼ äº†æ–‡ä»¶ ${file.name}ï¼Œè¯·å¸®æˆ‘åˆ†æè¿™ä¸ªæ–‡ä»¶çš„å†…å®¹`;
                    }
                    
                    updateStatus("âœ… æ–‡ä»¶å¤„ç†å®Œæˆ");
                } else {
                    filePreview.innerHTML += `<br>âŒ å¤„ç†å¤±è´¥: ${result.error}`;
                    updateStatus("âŒ æ–‡ä»¶å¤„ç†å¤±è´¥");
                }
            } catch (error) {
                filePreview.innerHTML += `<br>âŒ ä¸Šä¼ å¤±è´¥: ${error.message}`;
                updateStatus("âŒ ä¸Šä¼ å¤±è´¥");
            }
        }

        // æ›´æ–°æ¨¡å‹ä¿¡æ¯
        function updateModelInfo() {
            const selected = modelSelect.value;
            const option = modelSelect.options[modelSelect.selectedIndex];
            const modelInfo = document.getElementById('modelInfo');
            modelInfo.textContent = `å·²é€‰æ‹©: ${option.text}`;
            updateStatus(`æ¨¡å‹å·²åˆ‡æ¢åˆ°: ${option.text}`);
        }

        // åŠ è½½å¯ç”¨æ¨¡å‹
        async function loadAvailableModels() {
            try {
                const response = await fetch('/api/models');
                const data = await response.json();
                
                if (data.success && data.models) {
                    availableModels = data.models;
                    
                    // æ›´æ–°æ¨¡å‹é€‰æ‹©å™¨
                    modelSelect.innerHTML = '';
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = `${model.name} - ${model.size} ${model.type}${model.installed ? '' : ' (æœªå®‰è£…)'}`;
                        option.disabled = !model.installed;
                        if (model.id === data.current_model) {
                            option.selected = true;
                        }
                        modelSelect.appendChild(option);
                    });
                    
                    updateModelInfo();
                }
            } catch (error) {
                console.error('åŠ è½½æ¨¡å‹åˆ—è¡¨å¤±è´¥:', error);
            }
        }

        // åˆå§‹åŒ–ä¼šè¯ID
        function initSession() {
            // ç”Ÿæˆæ–°ä¼šè¯IDæˆ–ä½¿ç”¨ç°æœ‰çš„
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            currentSessionId = `${userId}_${timestamp}`;
            console.log(`ğŸ¯ ä¼šè¯ID: ${currentSessionId}`);
            
            // åŠ è½½ä¼šè¯ç»Ÿè®¡
            loadSessionStats();
        }
        
        // åŠ è½½ä¼šè¯ç»Ÿè®¡
        async function loadSessionStats() {
            if (!currentSessionId) return;
            
            try {
                const response = await fetch(`/api/context/stats/${currentSessionId}`);
                const data = await response.json();
                
                if (data.success && data.stats) {
                    updateMemoryInfo(data.stats);
                }
            } catch (error) {
                console.error('åŠ è½½ä¼šè¯ç»Ÿè®¡å¤±è´¥:', error);
            }
        }
        
        // æ¬¢è¿æ¶ˆæ¯
        window.onload = function() {
            // åˆå§‹åŒ–ä¼šè¯
            initSession();
            
            // åŠ è½½æ¨¡å‹åˆ—è¡¨
            loadAvailableModels();
            
            // å®šæ—¶æ£€æŸ¥æé†’ï¼ˆæ¯åˆ†é’Ÿï¼‰
            checkDueReminders();
            setInterval(checkDueReminders, 60000);
            
            setTimeout(() => {
                addMessage(`ğŸ‘‹ ä½ å¥½ï¼æˆ‘æ˜¯AI Stackæ™ºèƒ½åŠ©æ‰‹ã€‚

æˆ‘å¯ä»¥å¸®ä½ ï¼š
ğŸ“š æœç´¢çŸ¥è¯†åº“å’Œå¤–éƒ¨ç½‘ç«™
ğŸ’¼ æŸ¥è¯¢è´¢åŠ¡æ•°æ®ï¼ˆå®æ—¶API + å†å²ç›‘å¬ï¼‰
ğŸ“ˆ åˆ†æè‚¡ç¥¨è¡Œæƒ…
ğŸ¨ å†…å®¹åˆ›ä½œå»ºè®®
ğŸ“ å¤„ç†60+ç§æ ¼å¼æ–‡ä»¶
ğŸ¤ è¯­éŸ³äº¤äº’ï¼ˆè¾“å…¥/è¾“å‡ºï¼‰
ğŸ¤– æ‰§è¡Œå„ç§ä»»åŠ¡

æˆ‘ä¼šï¼š
âœ… è‡ªåŠ¨æ£€ç´¢RAGçŸ¥è¯†åº“å’Œå†å²ç»éªŒ
âœ… æœç´¢å¤–éƒ¨ç½‘ç«™è·å–æœ€æ–°ä¿¡æ¯
âœ… éªŒè¯ç»“æœçœŸå®æ€§å¹¶æ ‡æ³¨å·®å¼‚
âœ… æŒç»­å­¦ä¹ ç§¯ç´¯ç»éªŒ
âœ… è¶Šç”¨è¶Šèªæ˜

ğŸ¯ æ–°åŠŸèƒ½ï¼š
  ğŸ¤– é€‰æ‹©AIæ¨¡å‹ï¼ˆ7ç§æ¨¡å‹å¯é€‰ï¼‰
  ğŸŒ ç‚¹å‡»"ç½‘é¡µæœç´¢"å¯ç”¨å¤–éƒ¨æœç´¢
  ğŸ“ ç‚¹å‡»"ä¸Šä¼ æ–‡ä»¶"å¤„ç†æ–‡æ¡£
  ğŸ¤ ç‚¹å‡»"è¯­éŸ³è¾“å…¥"è¯­éŸ³æé—®

è¯•è¯•é—®æˆ‘ä¸€äº›é—®é¢˜å§ï¼`, false);
            }, 500);
        };
    </script>
    
    <!-- æ‹–æ‹½ä¸Šä¼ åŠŸèƒ½ -->
    <script>
        // å†…åµŒæ‹–æ‹½åŠŸèƒ½ï¼ˆé¿å…åŠ è½½å¤–éƒ¨JSï¼‰
        function initDragDrop() {
            const dropZone = document.querySelector('.chat-container');
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });
            
            dropZone.addEventListener('dragover', () => {
                dropZone.style.border = '3px dashed #667eea';
                dropZone.style.background = 'rgba(102, 126, 234, 0.05)';
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.style.border = '';
                dropZone.style.background = '';
            });
            
            dropZone.addEventListener('drop', async (e) => {
                dropZone.style.border = '';
                dropZone.style.background = '';
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    for (let file of files) {
                        await uploadDroppedFile(file);
                    }
                }
            });
        }
        
        async function uploadDroppedFile(file) {
            addMessage(`ğŸ“ æ­£åœ¨ä¸Šä¼ : ${file.name}`, true);
            updateStatus(`ğŸ“¤ ä¸Šä¼ ä¸­...`);
            
            const formData = new FormData();
            formData.append('file', file);
            formData.append('user_id', 'user_001');
            
            try {
                const response = await fetch('/api/file/upload', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.success) {
                    let msg = `âœ… æ–‡ä»¶å·²ä¸Šä¼ : ${file.name}\n`;
                    msg += `æ ¼å¼: ${result.format} | å¤§å°: ${(result.size/1024).toFixed(2)} KB\n`;
                    
                    if (result.type === 'text' && result.content) {
                        msg += `\nğŸ“„ å†…å®¹é¢„è§ˆ:\n${result.content.substring(0, 200)}...`;
                    }
                    
                    if (result.rag_saved) {
                        msg += `\n\nğŸ’¾ å·²ä¿å­˜åˆ°çŸ¥è¯†åº“`;
                    }
                    
                    addMessage(msg, false);
                    updateStatus("âœ… ä¸Šä¼ å®Œæˆ");
                } else {
                    addMessage(`âŒ ä¸Šä¼ å¤±è´¥: ${result.error}`, false);
                }
            } catch (error) {
                addMessage(`âŒ ä¸Šä¼ å‡ºé”™: ${error.message}`, false);
            }
        }
        
        // åˆå§‹åŒ–æ‹–æ‹½
        setTimeout(initDragDrop, 1000);
    </script>
    
    <!-- è¯­éŸ³å½•åˆ¶åŠŸèƒ½ - ç®€åŒ–ç‰ˆï¼Œæ— éœ€é¢å¤–è½¯ä»¶ -->
    <script>
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        
        // é‡å†™toggleVoiceå‡½æ•°
        window.toggleVoice = async function() {
            const btn = document.getElementById('voiceBtn');
            
            if (!isRecording) {
                // å¼€å§‹å½•éŸ³
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    recordedChunks = [];
                    
                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            recordedChunks.push(e.data);
                        }
                    };
                    
                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                        await processVoiceInput(audioBlob);
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    mediaRecorder.start();
                    isRecording = true;
                    btn.innerHTML = 'ğŸ”´ åœæ­¢å½•éŸ³';
                    btn.style.background = '#ef4444';
                    updateStatus("ğŸ¤ æ­£åœ¨å½•éŸ³... å†æ¬¡ç‚¹å‡»åœæ­¢");
                    
                } catch (error) {
                    alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™');
                    console.error(error);
                }
            } else {
                // åœæ­¢å½•éŸ³
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    isRecording = false;
                    btn.innerHTML = 'ğŸ¤ è¯­éŸ³è¾“å…¥';
                    btn.style.background = '';
                    updateStatus("ğŸ”„ æ­£åœ¨å¤„ç†è¯­éŸ³...");
                }
            }
        };
        
        async function processVoiceInput(audioBlob) {
            const formData = new FormData();
            formData.append('audio_file', audioBlob, 'voice.webm');
            
            try {
                const response = await fetch('/api/voice/stt', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.success && result.text) {
                    // æ˜¾ç¤ºè¯†åˆ«ç»“æœ
                    userInput.value = result.text;
                    addMessage(`ğŸ¤ è¯­éŸ³è¯†åˆ«: ${result.text}`, true);
                    updateStatus(`âœ… è¯†åˆ«å®Œæˆ: ${result.text.substring(0, 20)}...`);
                } else {
                    addMessage(`âš ï¸ è¯­éŸ³è¯†åˆ«: ${result.note || result.error || 'éœ€è¦å®‰è£…Whisperæ¨¡å‹'}`, false);
                    updateStatus("âš ï¸ è¯­éŸ³è¯†åˆ«ä¸å¯ç”¨");
                }
            } catch (error) {
                addMessage(`âŒ è¯­éŸ³å¤„ç†å¤±è´¥: ${error.message}`, false);
            }
        }
    </script>
    
    <style>
        /* æ‹–æ‹½æç¤ºæ ·å¼ */
        .drag-over {
            border: 3px dashed #667eea !important;
            background: rgba(102, 126, 234, 0.05) !important;
        }
        
        .drop-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px 50px;
            background: rgba(102, 126, 234, 0.95);
            color: white;
            border-radius: 15px;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            display: none;
            z-index: 9999;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        /* è¯­éŸ³æ’­æ”¾æŒ‰é’®æ ·å¼ */
        .audio-play-btn {
            padding: 6px 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        .audio-play-btn:hover {
            background: #5568d3;
        }
        
        .audio-play-btn:disabled {
            background: #94a3b8;
            cursor: not-allowed;
        }
        
        /* å½•éŸ³æŒ‰é’®çŠ¶æ€ */
        #voiceBtn.recording {
            background: #ef4444 !important;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }
        
        .message-text {
            margin-top: 5px;
        }
    </style>
</body>
</html>

