# ğŸ“ å¤‡å¿˜å½•ç³»ç»Ÿè®¾è®¡æ–‡æ¡£

**ç‰ˆæœ¬**: V1.0
**æ—¥æœŸ**: 2025-11-11
**ä¼˜å…ˆçº§**: P0ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
**é¢„è®¡å¼€å‘æ—¶é—´**: 2å¤©

---

## ğŸ¯ éœ€æ±‚æ¥æº

**ç”¨æˆ·éœ€æ±‚åŸæ–‡**ï¼š
> "1ï¼‰è¯†åˆ«äº¤äº’ä¿¡æ¯åˆ°å¤‡å¿˜å½•ï¼›
> 2ï¼‰ä»å¤‡å¿˜å½•ä¸­æç‚¼ä»»åŠ¡åˆ°æ™ºèƒ½å·¥ä½œè®¡åˆ’ä¸­ï¼›"

**ç”¨æˆ·è¯¦ç»†è¯´æ˜**ï¼š
> "èŠå¤©æ¡†è¯†åˆ«ã€æ”¶é›†è¿›å…¥å¤‡å¿˜å½•çš„é‡è¦ä¿¡æ¯ï¼Œæˆ–è‡ªæˆ‘å­¦ä¹ è¿›åŒ–æ™ºèƒ½ä½“æä¾›ä¿¡æ¯ï¼Œæˆ–è€…ç”¨æˆ·åœ¨æ™ºèƒ½å·¥ä½œè®¡åˆ’ä¸ä»»åŠ¡äºŒçº§ç•Œé¢è‡ªå®šä¹‰ä»»åŠ¡å’Œè®¡åˆ’ï¼Œç»¼åˆåˆ†ç±»åç»™ç”¨æˆ·ç¡®å®šè®¡åˆ’"

---

## ğŸ“Š ç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    è¶…çº§AgentèŠå¤©æ¡†                        â”‚
â”‚  (ç”¨æˆ·è¾“å…¥/AIå›å¤) â†’ æ™ºèƒ½è¯†åˆ« â†’ å¤‡å¿˜å½•                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å¤‡å¿˜å½•ç³»ç»Ÿ                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  ä»»åŠ¡ç±»  â”‚  æƒ³æ³•ç±»  â”‚  æé†’ç±»  â”‚  å…¶ä»–ç±»  â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚  [æ™ºèƒ½åˆ†ç±»] [æ ‡ç­¾ç®¡ç†] [ä¼˜å…ˆçº§] [æœç´¢æ£€ç´¢]               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ä»»åŠ¡æç‚¼å¼•æ“                             â”‚
â”‚  AIåˆ†æ â†’ æç‚¼å¯æ‰§è¡Œä»»åŠ¡ â†’ æ™ºèƒ½å·¥ä½œè®¡åˆ’                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                æ™ºèƒ½å·¥ä½œè®¡åˆ’ç³»ç»Ÿ                           â”‚
â”‚  [ä»»åŠ¡çœ‹æ¿] [æ—¶é—´çº¿] [è¿›åº¦è¿½è¸ª] [æé†’é€šçŸ¥]                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ—ï¸ æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

### 1. æ™ºèƒ½è¯†åˆ«å¼•æ“ (Intelligent Recognition Engine)

**åŠŸèƒ½**: ä»èŠå¤©å¯¹è¯ä¸­è‡ªåŠ¨è¯†åˆ«é‡è¦ä¿¡æ¯

**è¯†åˆ«è§„åˆ™**:
- ğŸ¯ **ä»»åŠ¡ç±»**:
  - åŒ…å«åŠ¨è¯ï¼šåšã€å®Œæˆã€å¼€å‘ã€è®¾è®¡ã€å®ç°ã€ä¿®å¤ã€ä¼˜åŒ–ç­‰
  - åŒ…å«æ—¶é—´ï¼šæ˜å¤©ã€ä¸‹å‘¨ã€æœ¬æœˆã€æˆªæ­¢æ—¥æœŸç­‰
  - åŒ…å«æŒ‡ä»¤æ€§è¯­æ°”ï¼š"éœ€è¦"ã€"å¿…é¡»"ã€"è®°å¾—"ã€"åˆ«å¿˜äº†"
  - ç¤ºä¾‹ï¼š
    - "æ˜å¤©éœ€è¦å®ŒæˆERPæŠ¥è¡¨åŠŸèƒ½"
    - "ä¸‹å‘¨ä¸€æäº¤é¡¹ç›®è®¡åˆ’"
    - "è®°å¾—ä¿®å¤é‚£ä¸ªç™»å½•bug"

- ğŸ’¡ **æƒ³æ³•ç±»**:
  - åŒ…å«å…³é”®è¯ï¼šæƒ³æ³•ã€çµæ„Ÿã€å»ºè®®ã€å¯ä»¥è€ƒè™‘ã€æˆ–è®¸ã€å¦‚æœç­‰
  - æ¢è®¨æ€§è¯­æ°”
  - ç¤ºä¾‹ï¼š
    - "æˆ‘è§‰å¾—å¯ä»¥å¢åŠ ä¸€ä¸ªç”¨æˆ·ç”»åƒåŠŸèƒ½"
    - "æˆ–è®¸æˆ‘ä»¬åº”è¯¥é‡æ„è¿™ä¸ªæ¨¡å—"

- â° **æé†’ç±»**:
  - æ˜ç¡®çš„æ—¶é—´ç‚¹
  - æé†’åŠ¨ä½œï¼šæé†’ã€é€šçŸ¥ã€ä¸è¦å¿˜è®°
  - ç¤ºä¾‹ï¼š
    - "ä¸‹åˆ3ç‚¹å¼€ä¼š"
    - "å‘¨äº”è®°å¾—å¤‡ä»½æ•°æ®åº“"

- ğŸ“Œ **é‡è¦ä¿¡æ¯ç±»**:
  - ç”¨æˆ·æ˜ç¡®æ ‡è®°ï¼šé‡è¦ã€å…³é”®ã€æ³¨æ„ã€åŠ¡å¿…
  - åŒ…å«æ•°å­—ã€è´¦å·ã€å¯†ç ã€é“¾æ¥ç­‰å…³é”®æ•°æ®
  - ç¤ºä¾‹ï¼š
    - "é‡è¦ï¼šAPIå¯†é’¥æ˜¯ xyz123"
    - "å®¢æˆ·è”ç³»æ–¹å¼ï¼š138xxxx"

**AIæ¨¡å‹**:
```python
from typing import Dict, List
import re
from datetime import datetime

class MemoRecognizer:
    """å¤‡å¿˜å½•æ™ºèƒ½è¯†åˆ«å¼•æ“"""
    
    def __init__(self, llm_client):
        self.llm = llm_client
        self.patterns = self._init_patterns()
    
    def _init_patterns(self) -> Dict:
        """åˆå§‹åŒ–è¯†åˆ«æ¨¡å¼"""
        return {
            'task': {
                'keywords': ['éœ€è¦', 'å®Œæˆ', 'å¼€å‘', 'è®¾è®¡', 'å®ç°', 'ä¿®å¤', 'ä¼˜åŒ–', 
                           'åš', 'å¤„ç†', 'è§£å†³', 'è®°å¾—', 'åˆ«å¿˜äº†', 'å¿…é¡»'],
                'time_keywords': ['æ˜å¤©', 'ä¸‹å‘¨', 'æœ¬æœˆ', 'æˆªæ­¢', 'ä»Šå¤©', 'é©¬ä¸Š'],
                'pattern': r'(æ˜å¤©|ä¸‹å‘¨|æœ¬æœˆ|ä»Šå¤©).*(éœ€è¦|å®Œæˆ|åš|å®ç°|ä¿®å¤)'
            },
            'idea': {
                'keywords': ['æƒ³æ³•', 'çµæ„Ÿ', 'å»ºè®®', 'å¯ä»¥è€ƒè™‘', 'æˆ–è®¸', 'å¦‚æœ', 
                           'ä¸å¦‚', 'æ˜¯å¦', 'ä¹Ÿè®¸'],
                'pattern': r'(æƒ³æ³•|å»ºè®®|å¯ä»¥è€ƒè™‘|æˆ–è®¸|å¦‚æœ).+'
            },
            'reminder': {
                'keywords': ['æé†’', 'é€šçŸ¥', 'ä¸è¦å¿˜è®°', 'è®°å¾—'],
                'time_pattern': r'\d+[ç‚¹æ—¶]|\d+[æœˆæ—¥]|å‘¨[ä¸€äºŒä¸‰å››äº”å…­æ—¥]',
                'pattern': r'(\d+[ç‚¹æ—¶]|\d+[æœˆæ—¥]|å‘¨[ä¸€äºŒä¸‰å››äº”å…­æ—¥]).*(æé†’|è®°å¾—)'
            },
            'important': {
                'keywords': ['é‡è¦', 'å…³é”®', 'æ³¨æ„', 'åŠ¡å¿…', 'è­¦å‘Š'],
                'pattern': r'(é‡è¦|å…³é”®|æ³¨æ„|åŠ¡å¿…)[:ï¼š].+'
            }
        }
    
    def recognize(self, text: str, context: Dict = None) -> Dict:
        """è¯†åˆ«æ–‡æœ¬ä¸­çš„å¤‡å¿˜å½•ä¿¡æ¯
        
        Args:
            text: è¾“å…¥æ–‡æœ¬
            context: ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼ˆå¯¹è¯å†å²ç­‰ï¼‰
            
        Returns:
            {
                'is_memo': bool,
                'type': 'task' | 'idea' | 'reminder' | 'important',
                'content': str,
                'priority': 'high' | 'medium' | 'low',
                'due_date': datetime or None,
                'tags': List[str],
                'confidence': float  # ç½®ä¿¡åº¦ 0-1
            }
        """
        # 1. åŸºäºè§„åˆ™çš„å¿«é€Ÿè¯†åˆ«
        rule_result = self._rule_based_recognition(text)
        
        # 2. å¦‚æœè§„åˆ™è¯†åˆ«ç½®ä¿¡åº¦ä½ï¼Œä½¿ç”¨AIå¢å¼ºè¯†åˆ«
        if rule_result['confidence'] < 0.7:
            ai_result = self._ai_enhanced_recognition(text, context)
            result = self._merge_results(rule_result, ai_result)
        else:
            result = rule_result
        
        return result
    
    def _rule_based_recognition(self, text: str) -> Dict:
        """åŸºäºè§„åˆ™çš„è¯†åˆ«"""
        result = {
            'is_memo': False,
            'type': None,
            'content': text,
            'priority': 'medium',
            'due_date': None,
            'tags': [],
            'confidence': 0.0
        }
        
        max_confidence = 0.0
        detected_type = None
        
        # æ£€æŸ¥å„ç§ç±»å‹
        for memo_type, config in self.patterns.items():
            confidence = 0.0
            
            # å…³é”®è¯åŒ¹é…
            keyword_matches = sum(1 for kw in config['keywords'] if kw in text)
            confidence += keyword_matches * 0.2
            
            # æ­£åˆ™åŒ¹é…
            if 'pattern' in config and re.search(config['pattern'], text):
                confidence += 0.4
            
            # ç‰¹æ®Šè§„åˆ™
            if memo_type == 'task':
                # æ£€æŸ¥æ—¶é—´è¯
                if any(tw in text for tw in config['time_keywords']):
                    confidence += 0.2
                    result['priority'] = 'high'
            
            if memo_type == 'reminder':
                # æ£€æŸ¥æ—¶é—´æ¨¡å¼
                if 'time_pattern' in config and re.search(config['time_pattern'], text):
                    confidence += 0.3
                    result['priority'] = 'high'
                    # æå–æ—¶é—´
                    result['due_date'] = self._extract_datetime(text)
            
            if memo_type == 'important':
                result['priority'] = 'high'
            
            if confidence > max_confidence:
                max_confidence = confidence
                detected_type = memo_type
        
        # åˆ¤æ–­æ˜¯å¦ä¸ºå¤‡å¿˜å½•
        if max_confidence > 0.5:
            result['is_memo'] = True
            result['type'] = detected_type
            result['confidence'] = min(max_confidence, 1.0)
            result['tags'] = self._extract_tags(text)
        
        return result
    
    def _ai_enhanced_recognition(self, text: str, context: Dict = None) -> Dict:
        """AIå¢å¼ºè¯†åˆ«"""
        prompt = f"""åˆ†æä»¥ä¸‹å¯¹è¯å†…å®¹ï¼Œåˆ¤æ–­æ˜¯å¦åŒ…å«éœ€è¦è®°å½•åˆ°å¤‡å¿˜å½•çš„é‡è¦ä¿¡æ¯ã€‚

å¯¹è¯å†…å®¹ï¼š{text}

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼š
{{
    "is_memo": true/false,
    "type": "task|idea|reminder|important",
    "content": "æå–çš„æ ¸å¿ƒå†…å®¹",
    "priority": "high|medium|low",
    "due_date": "YYYY-MM-DD HH:mm" or null,
    "tags": ["æ ‡ç­¾1", "æ ‡ç­¾2"],
    "reason": "è¯†åˆ«ç†ç”±"
}}

è¯†åˆ«æ ‡å‡†ï¼š
- task: æ˜ç¡®çš„å¾…åŠäº‹é¡¹ã€éœ€è¦æ‰§è¡Œçš„æ“ä½œ
- idea: æƒ³æ³•ã€å»ºè®®ã€åˆ›æ„
- reminder: å¸¦æ—¶é—´çš„æé†’äº‹é¡¹
- important: é‡è¦ä¿¡æ¯ã€å…³é”®æ•°æ®

è¯·åˆ†æï¼š"""
        
        # è°ƒç”¨LLM
        response = self.llm.chat(prompt)
        
        try:
            import json
            result = json.loads(response)
            result['confidence'] = 0.8  # AIè¯†åˆ«ç½®ä¿¡åº¦
            return result
        except:
            return {'is_memo': False, 'confidence': 0.0}
    
    def _extract_datetime(self, text: str) -> datetime:
        """æå–æ—¶é—´ä¿¡æ¯"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„æ—¶é—´è§£æ
        import dateparser
        
        # æå–æ—¶é—´ç›¸å…³çš„æ–‡æœ¬ç‰‡æ®µ
        time_patterns = [
            r'(\d+[æœˆæ—¥])',
            r'(å‘¨[ä¸€äºŒä¸‰å››äº”å…­æ—¥])',
            r'(\d+[ç‚¹æ—¶])',
            r'(æ˜å¤©|åå¤©|ä¸‹å‘¨|ä¸‹æœˆ)'
        ]
        
        for pattern in time_patterns:
            match = re.search(pattern, text)
            if match:
                time_text = match.group(1)
                parsed_time = dateparser.parse(time_text, languages=['zh'])
                if parsed_time:
                    return parsed_time
        
        return None
    
    def _extract_tags(self, text: str) -> List[str]:
        """æå–æ ‡ç­¾"""
        tags = []
        
        # é¡¹ç›®/æ¨¡å—æ ‡ç­¾
        if 'ERP' in text:
            tags.append('ERP')
        if 'RAG' in text or 'çŸ¥è¯†åº“' in text:
            tags.append('RAG')
        if 'æµ‹è¯•' in text:
            tags.append('æµ‹è¯•')
        if 'å¼€å‘' in text:
            tags.append('å¼€å‘')
        if 'è®¾è®¡' in text:
            tags.append('è®¾è®¡')
        
        return tags
    
    def _merge_results(self, rule_result: Dict, ai_result: Dict) -> Dict:
        """åˆå¹¶è§„åˆ™å’ŒAIè¯†åˆ«ç»“æœ"""
        # å–ç½®ä¿¡åº¦é«˜çš„ç»“æœ
        if ai_result['confidence'] > rule_result['confidence']:
            return ai_result
        return rule_result
```

---

### 2. å¤‡å¿˜å½•å­˜å‚¨ç®¡ç† (Memo Storage & Management)

**æ•°æ®æ¨¡å‹**:
```python
from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel, Field
from enum import Enum

class MemoType(str, Enum):
    """å¤‡å¿˜å½•ç±»å‹"""
    TASK = "task"           # ä»»åŠ¡
    IDEA = "idea"           # æƒ³æ³•
    REMINDER = "reminder"   # æé†’
    IMPORTANT = "important" # é‡è¦ä¿¡æ¯
    OTHER = "other"         # å…¶ä»–

class MemoPriority(str, Enum):
    """ä¼˜å…ˆçº§"""
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"

class MemoStatus(str, Enum):
    """çŠ¶æ€"""
    ACTIVE = "active"       # æ´»è·ƒ
    ARCHIVED = "archived"   # å·²å½’æ¡£
    DELETED = "deleted"     # å·²åˆ é™¤
    CONVERTED = "converted" # å·²è½¬æ¢ä¸ºä»»åŠ¡

class Memo(BaseModel):
    """å¤‡å¿˜å½•æ•°æ®æ¨¡å‹"""
    id: str = Field(default_factory=lambda: f"memo_{datetime.now().timestamp()}")
    
    # åŸºç¡€ä¿¡æ¯
    type: MemoType
    content: str
    source: str = "chat"  # chat, manual, ai_learning
    
    # åˆ†ç±»å’Œä¼˜å…ˆçº§
    priority: MemoPriority = MemoPriority.MEDIUM
    tags: List[str] = []
    
    # æ—¶é—´ä¿¡æ¯
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
    due_date: Optional[datetime] = None
    reminder_time: Optional[datetime] = None
    
    # çŠ¶æ€
    status: MemoStatus = MemoStatus.ACTIVE
    
    # å…³è”ä¿¡æ¯
    conversation_id: Optional[str] = None  # å…³è”çš„å¯¹è¯ID
    user_id: str
    
    # AIè¯†åˆ«ä¿¡æ¯
    confidence: float = 1.0  # è¯†åˆ«ç½®ä¿¡åº¦
    ai_reason: Optional[str] = None  # AIè¯†åˆ«ç†ç”±
    
    # è½¬æ¢ä¿¡æ¯
    converted_to_task_id: Optional[str] = None  # å¦‚æœè½¬æ¢ä¸ºä»»åŠ¡ï¼Œè®°å½•ä»»åŠ¡ID
    
    # é™„åŠ ä¿¡æ¯
    attachments: List[str] = []  # é™„ä»¶é“¾æ¥
    related_memos: List[str] = []  # å…³è”çš„å…¶ä»–å¤‡å¿˜å½•
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }
```

**å­˜å‚¨æœåŠ¡**:
```python
from typing import List, Optional, Dict
from datetime import datetime, timedelta
import json
from pathlib import Path

class MemoStorageService:
    """å¤‡å¿˜å½•å­˜å‚¨æœåŠ¡"""
    
    def __init__(self, db_path: str = "data/memos.json"):
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self._ensure_db()
    
    def _ensure_db(self):
        """ç¡®ä¿æ•°æ®åº“æ–‡ä»¶å­˜åœ¨"""
        if not self.db_path.exists():
            self._save_db([])
    
    def _load_db(self) -> List[Dict]:
        """åŠ è½½æ•°æ®åº“"""
        with open(self.db_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    
    def _save_db(self, memos: List[Dict]):
        """ä¿å­˜æ•°æ®åº“"""
        with open(self.db_path, 'w', encoding='utf-8') as f:
            json.dump(memos, f, ensure_ascii=False, indent=2, default=str)
    
    def create(self, memo: Memo) -> Memo:
        """åˆ›å»ºå¤‡å¿˜å½•"""
        memos = self._load_db()
        memos.append(memo.dict())
        self._save_db(memos)
        return memo
    
    def get(self, memo_id: str) -> Optional[Memo]:
        """è·å–å¤‡å¿˜å½•"""
        memos = self._load_db()
        for m in memos:
            if m['id'] == memo_id:
                return Memo(**m)
        return None
    
    def update(self, memo_id: str, updates: Dict) -> Optional[Memo]:
        """æ›´æ–°å¤‡å¿˜å½•"""
        memos = self._load_db()
        for i, m in enumerate(memos):
            if m['id'] == memo_id:
                m.update(updates)
                m['updated_at'] = datetime.now().isoformat()
                memos[i] = m
                self._save_db(memos)
                return Memo(**m)
        return None
    
    def delete(self, memo_id: str, soft_delete: bool = True) -> bool:
        """åˆ é™¤å¤‡å¿˜å½•"""
        if soft_delete:
            return self.update(memo_id, {'status': MemoStatus.DELETED.value}) is not None
        else:
            memos = self._load_db()
            memos = [m for m in memos if m['id'] != memo_id]
            self._save_db(memos)
            return True
    
    def list(self, 
             user_id: str,
             type: Optional[MemoType] = None,
             status: MemoStatus = MemoStatus.ACTIVE,
             tags: Optional[List[str]] = None,
             priority: Optional[MemoPriority] = None,
             start_date: Optional[datetime] = None,
             end_date: Optional[datetime] = None,
             limit: int = 100) -> List[Memo]:
        """åˆ—å‡ºå¤‡å¿˜å½•"""
        memos = self._load_db()
        
        # è¿‡æ»¤
        filtered = []
        for m in memos:
            # ç”¨æˆ·è¿‡æ»¤
            if m['user_id'] != user_id:
                continue
            
            # çŠ¶æ€è¿‡æ»¤
            if m['status'] != status.value:
                continue
            
            # ç±»å‹è¿‡æ»¤
            if type and m['type'] != type.value:
                continue
            
            # ä¼˜å…ˆçº§è¿‡æ»¤
            if priority and m['priority'] != priority.value:
                continue
            
            # æ ‡ç­¾è¿‡æ»¤
            if tags and not any(tag in m['tags'] for tag in tags):
                continue
            
            # æ—¶é—´è¿‡æ»¤
            if start_date:
                memo_date = datetime.fromisoformat(m['created_at'])
                if memo_date < start_date:
                    continue
            
            if end_date:
                memo_date = datetime.fromisoformat(m['created_at'])
                if memo_date > end_date:
                    continue
            
            filtered.append(Memo(**m))
        
        # æ’åºï¼ˆæŒ‰åˆ›å»ºæ—¶é—´å€’åºï¼‰
        filtered.sort(key=lambda x: x.created_at, reverse=True)
        
        return filtered[:limit]
    
    def search(self, user_id: str, query: str, limit: int = 50) -> List[Memo]:
        """æœç´¢å¤‡å¿˜å½•"""
        memos = self._load_db()
        
        results = []
        query_lower = query.lower()
        
        for m in memos:
            if m['user_id'] != user_id:
                continue
            
            if m['status'] == MemoStatus.DELETED.value:
                continue
            
            # æœç´¢å†…å®¹ã€æ ‡ç­¾
            if (query_lower in m['content'].lower() or
                any(query_lower in tag.lower() for tag in m['tags'])):
                results.append(Memo(**m))
        
        return results[:limit]
    
    def get_upcoming_reminders(self, user_id: str, 
                               within_hours: int = 24) -> List[Memo]:
        """è·å–å³å°†åˆ°æœŸçš„æé†’"""
        memos = self._load_db()
        now = datetime.now()
        deadline = now + timedelta(hours=within_hours)
        
        upcoming = []
        for m in memos:
            if m['user_id'] != user_id:
                continue
            
            if m['status'] != MemoStatus.ACTIVE.value:
                continue
            
            # æ£€æŸ¥due_dateæˆ–reminder_time
            for time_field in ['due_date', 'reminder_time']:
                if m.get(time_field):
                    reminder_time = datetime.fromisoformat(m[time_field])
                    if now <= reminder_time <= deadline:
                        upcoming.append(Memo(**m))
                        break
        
        return sorted(upcoming, key=lambda x: x.due_date or x.reminder_time)
    
    def get_statistics(self, user_id: str) -> Dict:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        memos = self._load_db()
        
        user_memos = [m for m in memos if m['user_id'] == user_id]
        
        stats = {
            'total': len(user_memos),
            'by_type': {},
            'by_priority': {},
            'by_status': {},
            'active': 0,
            'high_priority': 0,
            'has_due_date': 0,
            'overdue': 0
        }
        
        now = datetime.now()
        
        for m in user_memos:
            # æŒ‰ç±»å‹
            type_key = m['type']
            stats['by_type'][type_key] = stats['by_type'].get(type_key, 0) + 1
            
            # æŒ‰ä¼˜å…ˆçº§
            pri_key = m['priority']
            stats['by_priority'][pri_key] = stats['by_priority'].get(pri_key, 0) + 1
            
            # æŒ‰çŠ¶æ€
            status_key = m['status']
            stats['by_status'][status_key] = stats['by_status'].get(status_key, 0) + 1
            
            # æ´»è·ƒæ•°é‡
            if m['status'] == MemoStatus.ACTIVE.value:
                stats['active'] += 1
            
            # é«˜ä¼˜å…ˆçº§æ•°é‡
            if m['priority'] == MemoPriority.HIGH.value:
                stats['high_priority'] += 1
            
            # æœ‰æˆªæ­¢æ—¥æœŸæ•°é‡
            if m.get('due_date'):
                stats['has_due_date'] += 1
                
                # è¿‡æœŸæ•°é‡
                due_date = datetime.fromisoformat(m['due_date'])
                if due_date < now and m['status'] == MemoStatus.ACTIVE.value:
                    stats['overdue'] += 1
        
        return stats
```

---

### 3. å¤‡å¿˜å½•APIæ¥å£

**FastAPIæ¥å£**:
```python
from fastapi import APIRouter, HTTPException, Depends
from typing import List, Optional
from datetime import datetime

router = APIRouter(prefix="/api/v1/memos", tags=["Memos"])

# ä¾èµ–æ³¨å…¥
def get_memo_service():
    return MemoStorageService()

def get_memo_recognizer():
    # éœ€è¦LLMå®¢æˆ·ç«¯
    from ai.llm_client import get_llm_client
    llm = get_llm_client()
    return MemoRecognizer(llm)

# ==================== åˆ›å»ºå¤‡å¿˜å½• ====================

@router.post("/", response_model=Memo)
async def create_memo(
    content: str,
    type: Optional[MemoType] = None,
    priority: Optional[MemoPriority] = None,
    tags: Optional[List[str]] = None,
    due_date: Optional[datetime] = None,
    user_id: str = "default_user",
    service: MemoStorageService = Depends(get_memo_service)
):
    """æ‰‹åŠ¨åˆ›å»ºå¤‡å¿˜å½•"""
    memo = Memo(
        content=content,
        type=type or MemoType.OTHER,
        priority=priority or MemoPriority.MEDIUM,
        tags=tags or [],
        due_date=due_date,
        user_id=user_id,
        source="manual"
    )
    
    return service.create(memo)

@router.post("/auto-recognize", response_model=Memo)
async def auto_recognize_and_create(
    text: str,
    conversation_id: Optional[str] = None,
    user_id: str = "default_user",
    recognizer: MemoRecognizer = Depends(get_memo_recognizer),
    service: MemoStorageService = Depends(get_memo_service)
):
    """æ™ºèƒ½è¯†åˆ«å¹¶åˆ›å»ºå¤‡å¿˜å½•"""
    # AIè¯†åˆ«
    recognition = recognizer.recognize(text)
    
    if not recognition['is_memo']:
        raise HTTPException(status_code=400, detail="æœªè¯†åˆ«åˆ°å¤‡å¿˜å½•ä¿¡æ¯")
    
    # åˆ›å»ºå¤‡å¿˜å½•
    memo = Memo(
        content=recognition['content'],
        type=MemoType(recognition['type']),
        priority=MemoPriority(recognition['priority']),
        tags=recognition['tags'],
        due_date=recognition['due_date'],
        user_id=user_id,
        source="chat",
        conversation_id=conversation_id,
        confidence=recognition['confidence'],
        ai_reason=recognition.get('reason')
    )
    
    return service.create(memo)

# ==================== æŸ¥è¯¢å¤‡å¿˜å½• ====================

@router.get("/", response_model=List[Memo])
async def list_memos(
    user_id: str = "default_user",
    type: Optional[MemoType] = None,
    status: MemoStatus = MemoStatus.ACTIVE,
    priority: Optional[MemoPriority] = None,
    tags: Optional[str] = None,  # é€—å·åˆ†éš”
    limit: int = 100,
    service: MemoStorageService = Depends(get_memo_service)
):
    """åˆ—å‡ºå¤‡å¿˜å½•"""
    tag_list = tags.split(',') if tags else None
    
    return service.list(
        user_id=user_id,
        type=type,
        status=status,
        priority=priority,
        tags=tag_list,
        limit=limit
    )

@router.get("/{memo_id}", response_model=Memo)
async def get_memo(
    memo_id: str,
    service: MemoStorageService = Depends(get_memo_service)
):
    """è·å–å•ä¸ªå¤‡å¿˜å½•"""
    memo = service.get(memo_id)
    if not memo:
        raise HTTPException(status_code=404, detail="å¤‡å¿˜å½•ä¸å­˜åœ¨")
    return memo

@router.get("/search/", response_model=List[Memo])
async def search_memos(
    query: str,
    user_id: str = "default_user",
    limit: int = 50,
    service: MemoStorageService = Depends(get_memo_service)
):
    """æœç´¢å¤‡å¿˜å½•"""
    return service.search(user_id, query, limit)

@router.get("/reminders/upcoming", response_model=List[Memo])
async def get_upcoming_reminders(
    user_id: str = "default_user",
    within_hours: int = 24,
    service: MemoStorageService = Depends(get_memo_service)
):
    """è·å–å³å°†åˆ°æœŸçš„æé†’"""
    return service.get_upcoming_reminders(user_id, within_hours)

@router.get("/statistics/", response_model=Dict)
async def get_memo_statistics(
    user_id: str = "default_user",
    service: MemoStorageService = Depends(get_memo_service)
):
    """è·å–ç»Ÿè®¡ä¿¡æ¯"""
    return service.get_statistics(user_id)

# ==================== æ›´æ–°å¤‡å¿˜å½• ====================

@router.put("/{memo_id}", response_model=Memo)
async def update_memo(
    memo_id: str,
    content: Optional[str] = None,
    type: Optional[MemoType] = None,
    priority: Optional[MemoPriority] = None,
    status: Optional[MemoStatus] = None,
    tags: Optional[List[str]] = None,
    due_date: Optional[datetime] = None,
    service: MemoStorageService = Depends(get_memo_service)
):
    """æ›´æ–°å¤‡å¿˜å½•"""
    updates = {}
    if content is not None:
        updates['content'] = content
    if type is not None:
        updates['type'] = type.value
    if priority is not None:
        updates['priority'] = priority.value
    if status is not None:
        updates['status'] = status.value
    if tags is not None:
        updates['tags'] = tags
    if due_date is not None:
        updates['due_date'] = due_date.isoformat()
    
    memo = service.update(memo_id, updates)
    if not memo:
        raise HTTPException(status_code=404, detail="å¤‡å¿˜å½•ä¸å­˜åœ¨")
    return memo

# ==================== åˆ é™¤å¤‡å¿˜å½• ====================

@router.delete("/{memo_id}")
async def delete_memo(
    memo_id: str,
    soft_delete: bool = True,
    service: MemoStorageService = Depends(get_memo_service)
):
    """åˆ é™¤å¤‡å¿˜å½•"""
    success = service.delete(memo_id, soft_delete)
    if not success:
        raise HTTPException(status_code=404, detail="å¤‡å¿˜å½•ä¸å­˜åœ¨")
    return {"message": "åˆ é™¤æˆåŠŸ"}

# ==================== æ‰¹é‡æ“ä½œ ====================

@router.post("/batch/archive")
async def batch_archive(
    memo_ids: List[str],
    service: MemoStorageService = Depends(get_memo_service)
):
    """æ‰¹é‡å½’æ¡£"""
    for memo_id in memo_ids:
        service.update(memo_id, {'status': MemoStatus.ARCHIVED.value})
    return {"message": f"å·²å½’æ¡£ {len(memo_ids)} æ¡å¤‡å¿˜å½•"}

@router.post("/batch/delete")
async def batch_delete(
    memo_ids: List[str],
    soft_delete: bool = True,
    service: MemoStorageService = Depends(get_memo_service)
):
    """æ‰¹é‡åˆ é™¤"""
    for memo_id in memo_ids:
        service.delete(memo_id, soft_delete)
    return {"message": f"å·²åˆ é™¤ {len(memo_ids)} æ¡å¤‡å¿˜å½•"}
```

---

### 4. å‰ç«¯é›†æˆ

**èŠå¤©æ¡†é›†æˆæ–¹æ¡ˆ**:

```javascript
// memo_integration.js

class MemoIntegration {
    constructor() {
        this.apiBase = '/api/v1/memos';
        this.autoRecognition = true;  // æ˜¯å¦è‡ªåŠ¨è¯†åˆ«
        this.pendingMemos = [];  // å¾…ç¡®è®¤çš„å¤‡å¿˜å½•
    }
    
    // ç›‘å¬èŠå¤©æ¶ˆæ¯
    onChatMessage(message, conversationId) {
        if (!this.autoRecognition) return;
        
        // è°ƒç”¨è¯†åˆ«API
        this.recognizeMemo(message.content, conversationId);
    }
    
    // è¯†åˆ«å¤‡å¿˜å½•
    async recognizeMemo(text, conversationId) {
        try {
            const response = await fetch(`${this.apiBase}/auto-recognize`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    text: text,
                    conversation_id: conversationId
                })
            });
            
            if (response.ok) {
                const memo = await response.json();
                
                // å¦‚æœç½®ä¿¡åº¦é«˜ï¼Œç›´æ¥ä¿å­˜
                if (memo.confidence > 0.8) {
                    this.showMemoNotification(memo, 'auto_saved');
                } else {
                    // ç½®ä¿¡åº¦ä½ï¼Œè¯¢é—®ç”¨æˆ·
                    this.askUserConfirmation(memo);
                }
            }
        } catch (error) {
            console.error('å¤‡å¿˜å½•è¯†åˆ«å¤±è´¥:', error);
        }
    }
    
    // æ˜¾ç¤ºå¤‡å¿˜å½•é€šçŸ¥
    showMemoNotification(memo, action) {
        const notification = `
            <div class="memo-notification">
                <div class="memo-icon ${memo.type}"></div>
                <div class="memo-content">
                    <div class="memo-title">
                        ${action === 'auto_saved' ? 'âœ… å·²è‡ªåŠ¨ä¿å­˜åˆ°å¤‡å¿˜å½•' : 'â“ æ£€æµ‹åˆ°å¤‡å¿˜å½•'}
                    </div>
                    <div class="memo-text">${memo.content}</div>
                    <div class="memo-meta">
                        <span class="memo-type">${this.getTypeLabel(memo.type)}</span>
                        <span class="memo-priority">${this.getPriorityLabel(memo.priority)}</span>
                    </div>
                </div>
                <div class="memo-actions">
                    <button onclick="viewMemo('${memo.id}')">æŸ¥çœ‹</button>
                    ${action !== 'auto_saved' ? `
                        <button onclick="confirmMemo('${memo.id}')">ç¡®è®¤</button>
                        <button onclick="ignoreMemo('${memo.id}')">å¿½ç•¥</button>
                    ` : ''}
                </div>
            </div>
        `;
        
        // æ˜¾ç¤ºé€šçŸ¥ï¼ˆå¯ä»¥ç”¨Toastæˆ–è€…åœ¨èŠå¤©ç•Œé¢ä¸Šæ–¹æ˜¾ç¤ºï¼‰
        this.showToast(notification);
    }
    
    // è¯·æ±‚ç”¨æˆ·ç¡®è®¤
    askUserConfirmation(memo) {
        this.pendingMemos.push(memo);
        this.showMemoNotification(memo, 'need_confirm');
    }
    
    // æ‰‹åŠ¨åˆ›å»ºå¤‡å¿˜å½•æŒ‰é’®
    showManualCreateButton() {
        // åœ¨èŠå¤©è¾“å…¥æ¡†æ—è¾¹æ˜¾ç¤º"æ·»åŠ å¤‡å¿˜å½•"æŒ‰é’®
        return `
            <button class="memo-create-btn" onclick="openMemoDialog()">
                ğŸ“ æ·»åŠ å¤‡å¿˜å½•
            </button>
        `;
    }
    
    // æ‰“å¼€å¤‡å¿˜å½•å¯¹è¯æ¡†
    openMemoDialog(defaultContent = '') {
        const dialog = `
            <div class="memo-dialog">
                <h3>åˆ›å»ºå¤‡å¿˜å½•</h3>
                <form id="memo-form">
                    <div class="form-group">
                        <label>å†…å®¹</label>
                        <textarea name="content" required>${defaultContent}</textarea>
                    </div>
                    <div class="form-group">
                        <label>ç±»å‹</label>
                        <select name="type">
                            <option value="task">ä»»åŠ¡</option>
                            <option value="idea">æƒ³æ³•</option>
                            <option value="reminder">æé†’</option>
                            <option value="important">é‡è¦ä¿¡æ¯</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>ä¼˜å…ˆçº§</label>
                        <select name="priority">
                            <option value="high">é«˜</option>
                            <option value="medium" selected>ä¸­</option>
                            <option value="low">ä½</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>æ ‡ç­¾ï¼ˆé€—å·åˆ†éš”ï¼‰</label>
                        <input type="text" name="tags" placeholder="ERP, å¼€å‘, æµ‹è¯•">
                    </div>
                    <div class="form-group">
                        <label>æˆªæ­¢æ—¥æœŸ</label>
                        <input type="datetime-local" name="due_date">
                    </div>
                    <div class="form-actions">
                        <button type="submit">ä¿å­˜</button>
                        <button type="button" onclick="closeM emoDialog()">å–æ¶ˆ</button>
                    </div>
                </form>
            </div>
        `;
        
        // æ˜¾ç¤ºå¯¹è¯æ¡†
        this.showDialog(dialog);
    }
    
    // å¤‡å¿˜å½•åˆ—è¡¨ä¾§è¾¹æ 
    renderMemoSidebar() {
        return `
            <div class="memo-sidebar">
                <div class="memo-header">
                    <h3>ğŸ“ æˆ‘çš„å¤‡å¿˜å½•</h3>
                    <button onclick="openMemoDialog()">â•</button>
                </div>
                
                <div class="memo-filters">
                    <button class="filter-btn active" data-type="all">å…¨éƒ¨</button>
                    <button class="filter-btn" data-type="task">ä»»åŠ¡</button>
                    <button class="filter-btn" data-type="idea">æƒ³æ³•</button>
                    <button class="filter-btn" data-type="reminder">æé†’</button>
                </div>
                
                <div class="memo-list" id="memo-list">
                    <!-- åŠ¨æ€åŠ è½½ -->
                </div>
            </div>
        `;
    }
    
    // åŠ è½½å¤‡å¿˜å½•åˆ—è¡¨
    async loadMemos(filters = {}) {
        const params = new URLSearchParams(filters);
        const response = await fetch(`${this.apiBase}/?${params}`);
        const memos = await response.json();
        
        const listEl = document.getElementById('memo-list');
        listEl.innerHTML = memos.map(memo => this.renderMemoItem(memo)).join('');
    }
    
    // æ¸²æŸ“å•ä¸ªå¤‡å¿˜å½•é¡¹
    renderMemoItem(memo) {
        return `
            <div class="memo-item ${memo.priority}" data-id="${memo.id}">
                <div class="memo-item-icon ${memo.type}"></div>
                <div class="memo-item-content">
                    <div class="memo-item-text">${memo.content}</div>
                    <div class="memo-item-meta">
                        ${memo.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                        ${memo.due_date ? `<span class="due-date">ğŸ“… ${this.formatDate(memo.due_date)}</span>` : ''}
                    </div>
                </div>
                <div class="memo-item-actions">
                    <button onclick="editMemo('${memo.id}')">âœï¸</button>
                    <button onclick="deleteMemo('${memo.id}')">ğŸ—‘ï¸</button>
                </div>
            </div>
        `;
    }
    
    // å·¥å…·æ–¹æ³•
    getTypeLabel(type) {
        const labels = {
            'task': 'ğŸ“‹ ä»»åŠ¡',
            'idea': 'ğŸ’¡ æƒ³æ³•',
            'reminder': 'â° æé†’',
            'important': 'â­ é‡è¦'
        };
        return labels[type] || type;
    }
    
    getPriorityLabel(priority) {
        const labels = {
            'high': 'ğŸ”´ é«˜',
            'medium': 'ğŸŸ¡ ä¸­',
            'low': 'ğŸŸ¢ ä½'
        };
        return labels[priority] || priority;
    }
    
    formatDate(dateStr) {
        const date = new Date(dateStr);
        return date.toLocaleString('zh-CN');
    }
}

// åˆå§‹åŒ–
const memoIntegration = new MemoIntegration();
```

---

## ğŸ“± ç”¨æˆ·ç•Œé¢è®¾è®¡

### ä¸»ç•Œé¢é›†æˆæ–¹æ¡ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è¶…çº§AgentèŠå¤©ç•Œé¢                           [ğŸ“ å¤‡å¿˜å½• (5)] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  ğŸ’¬ ç”¨æˆ·: æ˜å¤©éœ€è¦å®ŒæˆERPæŠ¥è¡¨åŠŸèƒ½çš„å¼€å‘                       â”‚
â”‚                                                              â”‚
â”‚  ğŸ¤– Agent: å¥½çš„ï¼Œæˆ‘æ¥å¸®ä½ åˆ†æ...                             â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ âœ… å·²è‡ªåŠ¨ä¿å­˜åˆ°å¤‡å¿˜å½•                               â”‚    â”‚
â”‚  â”‚ ğŸ“‹ ä»»åŠ¡: å®ŒæˆERPæŠ¥è¡¨åŠŸèƒ½çš„å¼€å‘                      â”‚    â”‚
â”‚  â”‚ â° æˆªæ­¢: æ˜å¤©                                       â”‚    â”‚
â”‚  â”‚ ğŸ”´ ä¼˜å…ˆçº§: é«˜                                       â”‚    â”‚
â”‚  â”‚ [æŸ¥çœ‹è¯¦æƒ…] [è½¬ä¸ºå·¥ä½œè®¡åˆ’]                           â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                              â”‚
â”‚  ğŸ’¬ ç”¨æˆ·: ç»§ç»­...                                            â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å¤‡å¿˜å½•ä¾§è¾¹æ 

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“ æˆ‘çš„å¤‡å¿˜å½•    [â•] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [å…¨éƒ¨][ä»»åŠ¡][æƒ³æ³•][æé†’]â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                       â”‚
â”‚ ğŸ”´ ğŸ“‹ å®ŒæˆERPæŠ¥è¡¨      â”‚
â”‚    #ERP #å¼€å‘         â”‚
â”‚    ğŸ“… æ˜å¤©            â”‚
â”‚                       â”‚
â”‚ ğŸŸ¡ ğŸ’¡ å¢åŠ ç”¨æˆ·ç”»åƒ     â”‚
â”‚    #äº§å“ #æƒ³æ³•        â”‚
â”‚                       â”‚
â”‚ ğŸŸ¢ â° å‘¨äº”å¤‡ä»½æ•°æ®åº“   â”‚
â”‚    #è¿ç»´ #æé†’        â”‚
â”‚    ğŸ“… æœ¬å‘¨äº”          â”‚
â”‚                       â”‚
â”‚ â­ é‡è¦APIå¯†é’¥        â”‚
â”‚    #å®‰å…¨ #é‡è¦        â”‚
â”‚                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸš€ å¼€å‘è®¡åˆ’

### Day 1ï¼šæ ¸å¿ƒåŠŸèƒ½å¼€å‘
- âœ… ä¸Šåˆï¼šæ•°æ®æ¨¡å‹è®¾è®¡ï¼ˆMemoã€MemoTypeç­‰ï¼‰
- âœ… ä¸Šåˆï¼šæ™ºèƒ½è¯†åˆ«å¼•æ“ï¼ˆMemoRecognizerï¼‰
- âœ… ä¸‹åˆï¼šå­˜å‚¨æœåŠ¡ï¼ˆMemoStorageServiceï¼‰
- âœ… ä¸‹åˆï¼šAPIæ¥å£ï¼ˆFastAPI Routerï¼‰

### Day 2ï¼šå‰ç«¯é›†æˆä¸æµ‹è¯•
- â° ä¸Šåˆï¼šå‰ç«¯JSé›†æˆï¼ˆMemoIntegrationï¼‰
- â° ä¸Šåˆï¼šèŠå¤©æ¡†é›†æˆ
- â° ä¸‹åˆï¼šä¾§è¾¹æ UIå¼€å‘
- â° ä¸‹åˆï¼šåŠŸèƒ½æµ‹è¯•å’Œä¼˜åŒ–

---

## âœ… æµ‹è¯•è®¡åˆ’

### å•å…ƒæµ‹è¯•
```python
# test_memo_system.py

def test_memo_recognizer():
    """æµ‹è¯•å¤‡å¿˜å½•è¯†åˆ«"""
    recognizer = MemoRecognizer(mock_llm)
    
    # æµ‹è¯•ä»»åŠ¡è¯†åˆ«
    result = recognizer.recognize("æ˜å¤©éœ€è¦å®ŒæˆERPæŠ¥è¡¨åŠŸèƒ½")
    assert result['is_memo'] == True
    assert result['type'] == 'task'
    assert result['priority'] == 'high'
    
    # æµ‹è¯•æƒ³æ³•è¯†åˆ«
    result = recognizer.recognize("æˆ‘è§‰å¾—å¯ä»¥å¢åŠ ä¸€ä¸ªç”¨æˆ·ç”»åƒåŠŸèƒ½")
    assert result['type'] == 'idea'

def test_memo_storage():
    """æµ‹è¯•å¤‡å¿˜å½•å­˜å‚¨"""
    service = MemoStorageService(":memory:")
    
    memo = Memo(
        content="æµ‹è¯•å¤‡å¿˜å½•",
        type=MemoType.TASK,
        user_id="test_user"
    )
    
    # åˆ›å»º
    created = service.create(memo)
    assert created.id is not None
    
    # è·å–
    fetched = service.get(created.id)
    assert fetched.content == "æµ‹è¯•å¤‡å¿˜å½•"
    
    # æ›´æ–°
    updated = service.update(created.id, {'priority': 'high'})
    assert updated.priority == MemoPriority.HIGH
    
    # åˆ é™¤
    success = service.delete(created.id)
    assert success == True
```

### é›†æˆæµ‹è¯•
- âœ… èŠå¤©æ¡†è¯†åˆ«æµ‹è¯•
- âœ… æ‰‹åŠ¨åˆ›å»ºæµ‹è¯•
- âœ… åˆ—è¡¨æŸ¥è¯¢æµ‹è¯•
- âœ… æœç´¢åŠŸèƒ½æµ‹è¯•
- âœ… æé†’åŠŸèƒ½æµ‹è¯•

---

## ğŸ“ˆ ä¸‹ä¸€æ­¥ï¼ˆDay 3-4ï¼‰

å®Œæˆå¤‡å¿˜å½•ç³»ç»Ÿåï¼Œç«‹å³å¼€å§‹**ä»»åŠ¡æç‚¼å¼•æ“**å¼€å‘ï¼š

1. AIä»å¤‡å¿˜å½•æç‚¼ä»»åŠ¡
2. ä»»åŠ¡ä¼˜å…ˆçº§è¯„ä¼°
3. ä»»åŠ¡å…³è”å…³ç³»åˆ†æ
4. è‡ªåŠ¨è½¬æ¢ä¸ºå·¥ä½œè®¡åˆ’

---

*è®¾è®¡æ–‡æ¡£ V1.0*
*2025-11-11*




