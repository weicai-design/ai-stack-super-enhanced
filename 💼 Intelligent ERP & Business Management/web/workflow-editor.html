<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ERPæµç¨‹å¯è§†åŒ–ç¼–è¾‘å™¨ - AI-STACK</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/element-plus/dist/index.css">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/element-plus/dist/index.full.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-dagre@2.5.0/cytoscape-dagre.min.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .sidebar {
            width: 300px;
            background: #fff;
            border-right: 1px solid #e0e0e0;
            padding: 20px;
            overflow-y: auto;
        }
        .editor-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .toolbar {
            padding: 12px 20px;
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
        }
        .btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fff;
            cursor: pointer;
            font-size: 14px;
        }
        .btn:hover { background: #f0f0f0; }
        .btn-primary {
            background: #4caf50;
            color: #fff;
            border-color: #4caf50;
        }
        .btn-primary:hover { background: #45a049; }
        #cy {
            flex: 1;
            background: #fff;
        }
        .node-palette {
            margin-bottom: 20px;
        }
        .node-type {
            padding: 10px;
            margin-bottom: 8px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: move;
            font-size: 13px;
            user-select: none;
            -webkit-user-drag: element;
        }
        .node-type:hover {
            background: #f0f0f0;
        }
        .node-type[draggable="true"] {
            cursor: grab;
        }
        .node-type:active {
            cursor: grabbing;
        }
        h3 {
            margin-bottom: 15px;
            font-size: 16px;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- å·¦ä¾§å·¥å…·æ  -->
        <div class="sidebar">
            <h3>èŠ‚ç‚¹ç±»å‹</h3>
            <div class="node-palette">
                <div class="node-type" data-type="start">å¼€å§‹èŠ‚ç‚¹</div>
                <div class="node-type" data-type="task">ä»»åŠ¡èŠ‚ç‚¹</div>
                <div class="node-type" data-type="condition">æ¡ä»¶èŠ‚ç‚¹</div>
                <div class="node-type" data-type="parallel">å¹¶è¡ŒèŠ‚ç‚¹</div>
                <div class="node-type" data-type="approval">å®¡æ‰¹èŠ‚ç‚¹</div>
                <div class="node-type" data-type="notification">é€šçŸ¥èŠ‚ç‚¹</div>
                <div class="node-type" data-type="end">ç»“æŸèŠ‚ç‚¹</div>
            </div>
            
            <h3>æµç¨‹æ“ä½œ</h3>
            <div style="display: flex; flex-direction: column; gap: 8px;">
                <button class="btn btn-primary" onclick="saveWorkflow()">ğŸ’¾ ä¿å­˜æµç¨‹</button>
                <button class="btn" onclick="loadWorkflow()">ğŸ“‚ åŠ è½½æµç¨‹</button>
                <button class="btn" onclick="validateWorkflow()">âœ… éªŒè¯æµç¨‹</button>
                <button class="btn btn-primary" onclick="publishWorkflow()">ğŸš€ å‘å¸ƒæµç¨‹</button>
                <button class="btn" onclick="exportWorkflow()">ğŸ“¤ å¯¼å‡ºJSON</button>
                <button class="btn" onclick="importWorkflow()">ğŸ“¥ å¯¼å…¥JSON</button>
            </div>
            
            <h3 style="margin-top: 30px;">æµç¨‹æ¨¡æ¿</h3>
            <div style="display: flex; flex-direction: column; gap: 8px;">
                <button class="btn" onclick="loadTemplate('standard')">ğŸ“‹ æ ‡å‡†è®¢å•æµç¨‹</button>
                <button class="btn" onclick="loadTemplate('production')">ğŸ­ ç”Ÿäº§æµç¨‹</button>
                <button class="btn" onclick="loadTemplate('procurement')">ğŸ›’ é‡‡è´­æµç¨‹</button>
            </div>
            
            <h3 style="margin-top: 30px;">ğŸ“‹ æ™ºèƒ½å·¥ä½œè®¡åˆ’</h3>
            <div style="display: flex; flex-direction: column; gap: 8px;">
                <button class="btn btn-primary" onclick="loadTasksFromPlanning()">âœ¨ ä»å·¥ä½œè®¡åˆ’å¯¼å…¥ä»»åŠ¡</button>
                <button class="btn" onclick="showTaskPlanningPanel()">ğŸ“‹ æŸ¥çœ‹å·¥ä½œè®¡åˆ’</button>
                <button class="btn" onclick="createTaskFromMemo()">ğŸ“ ä»å¤‡å¿˜å½•åˆ›å»ºä»»åŠ¡</button>
            </div>
            <div id="task-planning-panel" style="margin-top: 15px; padding: 10px; background: #f9f9f9; border-radius: 4px; display: none;">
                <div id="tasks-list-container"></div>
            </div>
            
            <h3 style="margin-top: 30px;">ğŸ§® è¯•ç®—åŠŸèƒ½</h3>
            <div style="display: flex; flex-direction: column; gap: 8px;">
                <button class="btn btn-primary" onclick="showTrialBalancePanel()">ğŸ“Š æ‰“å¼€è¯•ç®—é¢æ¿</button>
                <button class="btn" onclick="calculateDailyDelivery()">ğŸ“ˆ æ¯æ—¥äº¤ä»˜é‡è¯•ç®—</button>
                <button class="btn" onclick="calculateProductionCapacity()">ğŸ­ äº§èƒ½è¯•ç®—</button>
                <button class="btn" onclick="calculateCostBreakdown()">ğŸ’° æˆæœ¬åˆ†è§£è¯•ç®—</button>
            </div>
            <div id="trial-balance-panel" style="margin-top: 15px; padding: 15px; background: #f9f9f9; border-radius: 4px; display: none;">
                <div id="trial-balance-content"></div>
            </div>
            
            <h3 style="margin-top: 30px;">èŠ‚ç‚¹å±æ€§</h3>
            <div id="node-properties" style="font-size: 12px; color: #666; padding: 10px; background: #f9f9f9; border-radius: 4px; margin-bottom: 15px; display: none;">
                <div><strong>èŠ‚ç‚¹åç§°ï¼š</strong><span id="prop-label">-</span></div>
                <div><strong>èŠ‚ç‚¹ç±»å‹ï¼š</strong><span id="prop-type">-</span></div>
                <div id="prop-assignee-div" style="display: none;"><strong>è´Ÿè´£äººï¼š</strong><span id="prop-assignee">-</span></div>
                <div id="prop-duration-div" style="display: none;"><strong>é¢„è®¡æ—¶é•¿ï¼š</strong><span id="prop-duration">-</span>å°æ—¶</div>
                <div id="prop-condition-div" style="display: none;"><strong>æ¡ä»¶è¡¨è¾¾å¼ï¼š</strong><span id="prop-condition">-</span></div>
            </div>
            
            <h3 style="margin-top: 30px;">ä½¿ç”¨è¯´æ˜</h3>
            <div style="font-size: 12px; color: #666; line-height: 1.6;">
                <p><strong>æ·»åŠ èŠ‚ç‚¹ï¼š</strong>ä»å·¦ä¾§æ‹–æ‹½èŠ‚ç‚¹åˆ°ç”»å¸ƒ</p>
                <p><strong>è¿æ¥èŠ‚ç‚¹ï¼š</strong>ç‚¹å‡»æºèŠ‚ç‚¹ï¼Œå†ç‚¹å‡»ç›®æ ‡èŠ‚ç‚¹</p>
                <p><strong>ç¼–è¾‘èŠ‚ç‚¹ï¼š</strong>åŒå‡»èŠ‚ç‚¹ç¼–è¾‘å±æ€§</p>
                <p><strong>ç¼–è¾‘è¿çº¿ï¼š</strong>åŒå‡»è¿çº¿ç¼–è¾‘æ ‡ç­¾</p>
                <p><strong>åˆ é™¤èŠ‚ç‚¹/è¿çº¿ï¼š</strong>Ctrl/Cmd + ç‚¹å‡»</p>
                <p><strong>ç§»åŠ¨èŠ‚ç‚¹ï¼š</strong>ç›´æ¥æ‹–æ‹½èŠ‚ç‚¹</p>
                <p><strong>æŸ¥çœ‹å±æ€§ï¼š</strong>ç‚¹å‡»èŠ‚ç‚¹æŸ¥çœ‹å±æ€§é¢æ¿</p>
                <p><strong>æ’¤é”€/é‡åšï¼š</strong>Ctrl+Z / Ctrl+Y</p>
                <p><strong>ä¿å­˜æµç¨‹ï¼š</strong>Ctrl+S</p>
            </div>
            
            <h3 style="margin-top: 30px;">å¿«æ·é”®</h3>
            <div style="font-size: 11px; color: #999; line-height: 1.5;">
                <p>Ctrl+Z / Cmd+Z - æ’¤é”€</p>
                <p>Ctrl+Y / Cmd+Y - é‡åš</p>
                <p>Ctrl+S / Cmd+S - ä¿å­˜</p>
                <p>Delete - åˆ é™¤é€‰ä¸­èŠ‚ç‚¹</p>
            </div>
        </div>

        <!-- ç¼–è¾‘å™¨åŒºåŸŸ -->
        <div class="editor-area">
            <div class="toolbar">
                <button class="btn" onclick="undo()" id="undo-btn" disabled>â†¶ æ’¤é”€</button>
                <button class="btn" onclick="redo()" id="redo-btn" disabled>â†· é‡åš</button>
                <div style="width: 1px; background: #ddd; margin: 0 10px;"></div>
                <button class="btn" onclick="zoomIn()">ğŸ” æ”¾å¤§</button>
                <button class="btn" onclick="zoomOut()">ğŸ” ç¼©å°</button>
                <button class="btn" onclick="resetView()">ğŸ¯ é‡ç½®è§†å›¾</button>
                <button class="btn" onclick="clearCanvas()">ğŸ—‘ï¸ æ¸…ç©º</button>
                <div style="width: 1px; background: #ddd; margin: 0 10px;"></div>
                <button class="btn" onclick="previewWorkflow()">ğŸ‘ï¸ é¢„è§ˆ</button>
                <button class="btn" onclick="simulateWorkflow()">â–¶ï¸ æ¨¡æ‹Ÿæ‰§è¡Œ</button>
                <div style="flex: 1;"></div>
                <span style="line-height: 32px; color: #666; font-size: 14px;">æµç¨‹å¯è§†åŒ–ç¼–è¾‘å™¨ v2.5</span>
            </div>
            <div id="cy"></div>
        </div>
    </div>

    <script>
        // åˆå§‹åŒ–Cytoscape
        const cy = cytoscape({
            container: document.getElementById('cy'),
            elements: [],
            style: [
                {
                    selector: 'node',
                    style: {
                        'label': 'data(label)',
                        'width': 100,
                        'height': 60,
                        'shape': 'round-rectangle',
                        'background-color': '#4caf50',
                        'color': '#fff',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '12px',
                        'border-width': '2px',
                        'border-color': '#333'
                    }
                },
                {
                    selector: 'node:selected',
                    style: {
                        'border-width': '4px',
                        'border-color': '#2196f3',
                        'background-color': '#66bb6a'
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 2,
                        'line-color': '#666',
                        'target-arrow-color': '#666',
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                        'label': 'data(label)'
                    }
                },
                {
                    selector: 'node[type="start"]',
                    style: {
                        'background-color': '#4caf50'
                    }
                },
                {
                    selector: 'node[type="end"]',
                    style: {
                        'background-color': '#f44336'
                    }
                },
                {
                    selector: 'node[type="condition"]',
                    style: {
                        'background-color': '#ff9800',
                        'shape': 'diamond'
                    }
                },
                {
                    selector: 'node[type="approval"]',
                    style: {
                        'background-color': '#9c27b0',
                        'shape': 'round-hexagon'
                    }
                },
                {
                    selector: 'node[type="notification"]',
                    style: {
                        'background-color': '#00bcd4',
                        'shape': 'round-pentagon'
                    }
                }
            ],
            layout: {
                name: 'dagre',
                rankDir: 'TB'
            }
        });

        let nodeCounter = 0;
        
        // æ’¤é”€/é‡åšåŠŸèƒ½
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;
        
        function saveHistory() {
            // ä¿å­˜å½“å‰çŠ¶æ€åˆ°å†å²è®°å½•
            const currentState = {
                nodes: cy.nodes().map(node => ({
                    id: node.id(),
                    data: node.data(),
                    position: node.position()
                })),
                edges: cy.edges().map(edge => ({
                    id: edge.id(),
                    data: edge.data(),
                    source: edge.source().id(),
                    target: edge.target().id()
                }))
            };
            
            // åˆ é™¤å½“å‰ä½ç½®ä¹‹åçš„å†å²
            history = history.slice(0, historyIndex + 1);
            history.push(JSON.parse(JSON.stringify(currentState)));
            historyIndex++;
            
            // é™åˆ¶å†å²è®°å½•æ•°é‡
            if (history.length > MAX_HISTORY) {
                history.shift();
                historyIndex--;
            }
            
            updateUndoRedoButtons();
        }
        
        function restoreHistory(state) {
            cy.elements().remove();
            
            // æ¢å¤èŠ‚ç‚¹
            state.nodes.forEach(nodeData => {
                cy.add({
                    group: 'nodes',
                    data: nodeData.data,
                    position: nodeData.position
                });
            });
            
            // æ¢å¤è¿çº¿
            state.edges.forEach(edgeData => {
                cy.add({
                    group: 'edges',
                    data: {
                        id: edgeData.id,
                        source: edgeData.source,
                        target: edgeData.target,
                        label: edgeData.data.label || ''
                    }
                });
            });
        }
        
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreHistory(history[historyIndex]);
                updateUndoRedoButtons();
            }
        }
        
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreHistory(history[historyIndex]);
                updateUndoRedoButtons();
            }
        }
        
        function updateUndoRedoButtons() {
            document.getElementById('undo-btn').disabled = historyIndex <= 0;
            document.getElementById('redo-btn').disabled = historyIndex >= history.length - 1;
        }
        
        // åˆå§‹åŒ–å†å²è®°å½•
        saveHistory();
        
        // ç›‘å¬å˜åŒ–ï¼Œè‡ªåŠ¨ä¿å­˜å†å²
        cy.on('add remove', 'node, edge', () => {
            saveHistory();
        });
        
        // å¿«æ·é”®æ”¯æŒ
        document.addEventListener('keydown', (e) => {
            // å¦‚æœæ­£åœ¨è¾“å…¥ï¼Œä¸å¤„ç†å¿«æ·é”®
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
            } else if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveWorkflow();
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                // åˆ é™¤é€‰ä¸­çš„èŠ‚ç‚¹
                const selected = cy.$('node:selected');
                if (selected.length > 0) {
                    e.preventDefault();
                    if (confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„${selected.length}ä¸ªèŠ‚ç‚¹å—ï¼Ÿ`)) {
                        selected.remove();
                        saveHistory();
                    }
                }
            }
        });

        // æ‹–æ‹½æ·»åŠ èŠ‚ç‚¹
        document.querySelectorAll('.node-type').forEach(nodeType => {
            nodeType.setAttribute('draggable', 'true');
            nodeType.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('node-type', nodeType.dataset.type);
                e.dataTransfer.effectAllowed = 'copy';
            });
        });

        document.getElementById('cy').addEventListener('drop', (e) => {
            e.preventDefault();
            const nodeType = e.dataTransfer.getData('node-type');
            if (nodeType) {
                const pos = cy.renderer().projectIntoViewport(e.clientX, e.clientY);
                addNode(nodeType, pos);
            }
        });

        document.getElementById('cy').addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        function addNode(type, position) {
            nodeCounter++;
            const labels = {
                'start': 'å¼€å§‹',
                'task': `ä»»åŠ¡${nodeCounter}`,
                'condition': `æ¡ä»¶${nodeCounter}`,
                'parallel': `å¹¶è¡Œ${nodeCounter}`,
                'approval': `å®¡æ‰¹${nodeCounter}`,
                'notification': `é€šçŸ¥${nodeCounter}`,
                'end': 'ç»“æŸ'
            };

            cy.add({
                group: 'nodes',
                data: {
                    id: `node_${nodeCounter}`,
                    label: labels[type] || `èŠ‚ç‚¹${nodeCounter}`,
                    type: type
                },
                position: position
            });
        }

        // è¿çº¿åŠŸèƒ½
        let sourceNode = null;
        cy.on('tap', 'node', (evt) => {
            const node = evt.target;
            if (evt.originalEvent.ctrlKey || evt.originalEvent.metaKey) {
                // Ctrl/Cmd + ç‚¹å‡»ï¼šåˆ é™¤èŠ‚ç‚¹
                if (confirm('ç¡®å®šè¦åˆ é™¤æ­¤èŠ‚ç‚¹å—ï¼Ÿ')) {
                    node.remove();
                }
                return;
            }
            
            if (!sourceNode) {
                sourceNode = node;
                node.style('border-width', '3px');
                node.style('border-color', '#2196f3');
                updateNodeProperties(node);
            } else {
                if (sourceNode.id() !== node.id()) {
                    cy.add({
                        group: 'edges',
                        data: {
                            id: `edge_${sourceNode.id()}_${node.id()}`,
                            source: sourceNode.id(),
                            target: node.id()
                        }
                    });
                }
                sourceNode.style('border-width', '2px');
                sourceNode.style('border-color', '#333');
                sourceNode = null;
                updateNodeProperties(node);
            }
        });
        
        // æ˜¾ç¤ºèŠ‚ç‚¹å±æ€§
        function updateNodeProperties(node) {
            const propsDiv = document.getElementById('node-properties');
            if (!propsDiv) return;
            
            propsDiv.style.display = 'block';
            document.getElementById('prop-label').textContent = node.data('label') || '-';
            document.getElementById('prop-type').textContent = getNodeTypeName(node.data('type'));
            
            const assigneeDiv = document.getElementById('prop-assignee-div');
            const durationDiv = document.getElementById('prop-duration-div');
            const conditionDiv = document.getElementById('prop-condition-div');
            
            if (node.data('type') === 'task') {
                assigneeDiv.style.display = 'block';
                durationDiv.style.display = 'block';
                conditionDiv.style.display = 'none';
                document.getElementById('prop-assignee').textContent = node.data('assignee') || 'æœªè®¾ç½®';
                document.getElementById('prop-duration').textContent = node.data('duration') || '0';
            } else if (node.data('type') === 'condition') {
                assigneeDiv.style.display = 'none';
                durationDiv.style.display = 'none';
                conditionDiv.style.display = 'block';
                document.getElementById('prop-condition').textContent = node.data('condition') || 'æœªè®¾ç½®';
            } else if (node.data('type') === 'approval') {
                assigneeDiv.style.display = 'block';
                durationDiv.style.display = 'none';
                conditionDiv.style.display = 'none';
                document.getElementById('prop-assignee').textContent = node.data('approver') || 'æœªè®¾ç½®';
            } else if (node.data('type') === 'notification') {
                assigneeDiv.style.display = 'none';
                durationDiv.style.display = 'none';
                conditionDiv.style.display = 'none';
            } else {
                assigneeDiv.style.display = 'none';
                durationDiv.style.display = 'none';
                conditionDiv.style.display = 'none';
            }
        }
        
        function getNodeTypeName(type) {
            const names = {
                'start': 'å¼€å§‹èŠ‚ç‚¹',
                'task': 'ä»»åŠ¡èŠ‚ç‚¹',
                'condition': 'æ¡ä»¶èŠ‚ç‚¹',
                'parallel': 'å¹¶è¡ŒèŠ‚ç‚¹',
                'approval': 'å®¡æ‰¹èŠ‚ç‚¹',
                'notification': 'é€šçŸ¥èŠ‚ç‚¹',
                'end': 'ç»“æŸèŠ‚ç‚¹'
            };
            return names[type] || type;
        }
        
        // ç‚¹å‡»ç©ºç™½å¤„å–æ¶ˆé€‰æ‹©
        cy.on('tap', (evt) => {
            if (evt.target === cy) {
                if (sourceNode) {
                    sourceNode.style('border-width', '2px');
                    sourceNode.style('border-color', '#333');
                    sourceNode = null;
                }
                document.getElementById('node-properties').style.display = 'none';
            }
        });

        // åˆ é™¤è¿çº¿
        cy.on('tap', 'edge', (evt) => {
            if (evt.originalEvent.ctrlKey || evt.originalEvent.metaKey) {
                if (confirm('ç¡®å®šè¦åˆ é™¤æ­¤è¿çº¿å—ï¼Ÿ')) {
                    evt.target.remove();
                }
            } else {
                // åŒå‡»ç¼–è¾‘è¿çº¿æ ‡ç­¾
                const edge = evt.target;
                const label = prompt('è¿çº¿æ ‡ç­¾:', edge.data('label') || '');
                if (label !== null) {
                    edge.data('label', label);
                }
            }
        });

        // å³é”®èœå•ï¼ˆå¯é€‰åŠŸèƒ½ï¼‰
        cy.on('cxttap', 'node', (evt) => {
            const node = evt.target;
            const action = confirm(`èŠ‚ç‚¹: ${node.data('label')}\n\né€‰æ‹©æ“ä½œ:\nç¡®å®š = ç¼–è¾‘\nå–æ¶ˆ = åˆ é™¤`);
            if (action) {
                showNodeConfigDialog(node);
            } else {
                if (confirm('ç¡®å®šè¦åˆ é™¤æ­¤èŠ‚ç‚¹å—ï¼Ÿ')) {
                    node.remove();
                }
            }
        });

        function zoomIn() {
            cy.zoom(cy.zoom() * 1.2);
        }

        function zoomOut() {
            cy.zoom(cy.zoom() * 0.8);
        }

        function resetView() {
            cy.fit();
        }

        function clearCanvas() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºç”»å¸ƒå—ï¼Ÿ')) {
                cy.elements().remove();
                nodeCounter = 0;
            }
        }

        function exportWorkflow() {
            const workflow = {
                name: 'å¯¼å‡ºæµç¨‹',
                nodes: cy.nodes().map(node => ({
                    id: node.id(),
                    label: node.data('label'),
                    type: node.data('type'),
                    position: node.position(),
                    assignee: node.data('assignee'),
                    duration: node.data('duration'),
                    condition: node.data('condition'),
                    properties: node.data('properties') || {}
                })),
                edges: cy.edges().map(edge => ({
                    id: edge.id(),
                    source: edge.source().id(),
                    target: edge.target().id(),
                    label: edge.data('label') || '',
                    condition: edge.data('condition')
                }))
            };
            
            const json = JSON.stringify(workflow, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'workflow_' + new Date().getTime() + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importWorkflow() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const workflow = JSON.parse(event.target.result);
                            loadWorkflowToCanvas(workflow);
                            alert('æµç¨‹å¯¼å…¥æˆåŠŸï¼');
                        } catch (error) {
                            alert('å¯¼å…¥å¤±è´¥: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        // èŠ‚ç‚¹é…ç½®å¯¹è¯æ¡†
        let currentNode = null;
        cy.on('dbltap', 'node', (evt) => {
            currentNode = evt.target;
            showNodeConfigDialog(currentNode);
        });
        
        // ä½¿èŠ‚ç‚¹å¯æ‹–æ‹½
        cy.nodes().on('drag', (evt) => {
            const node = evt.target;
            node.position({
                x: evt.position.x,
                y: evt.position.y
            });
        });

        // èŠ‚ç‚¹é…ç½®å¯¹è¯æ¡†ï¼ˆä½¿ç”¨Element Plusï¼‰
        function showNodeConfigDialog(node) {
            currentNode = node;
            const nodeType = node.data('type');
            
            // åˆ›å»ºé…ç½®å¯¹è¯æ¡†
            const dialogHtml = `
                <div id="node-config-dialog" style="padding: 20px;">
                    <h3 style="margin-bottom: 15px;">èŠ‚ç‚¹é…ç½®</h3>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">èŠ‚ç‚¹åç§°:</label>
                        <input id="node-label" type="text" value="${node.data('label') || ''}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" />
                    </div>
                    ${nodeType === 'task' ? `
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px;">è´Ÿè´£äºº:</label>
                            <input id="node-assignee" type="text" value="${node.data('assignee') || ''}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" />
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px;">é¢„è®¡æ—¶é•¿(å°æ—¶):</label>
                            <input id="node-duration" type="number" value="${node.data('duration') || ''}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" />
                        </div>
                    ` : ''}
                    ${nodeType === 'condition' ? `
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px;">æ¡ä»¶è¡¨è¾¾å¼:</label>
                            <textarea id="node-condition" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; min-height: 60px;">${node.data('condition') || ''}</textarea>
                        </div>
                    ` : ''}
                    ${nodeType === 'approval' ? `
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px;">å®¡æ‰¹äºº:</label>
                            <input id="node-approver" type="text" value="${node.data('approver') || ''}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" />
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px;">å®¡æ‰¹çº§åˆ«:</label>
                            <select id="node-approval-level" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="single" ${node.data('approval_level') === 'single' ? 'selected' : ''}>å•äººå®¡æ‰¹</option>
                                <option value="multi" ${node.data('approval_level') === 'multi' ? 'selected' : ''}>å¤šäººå®¡æ‰¹</option>
                                <option value="sequential" ${node.data('approval_level') === 'sequential' ? 'selected' : ''}>é¡ºåºå®¡æ‰¹</option>
                            </select>
                        </div>
                    ` : ''}
                    ${nodeType === 'notification' ? `
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px;">é€šçŸ¥æ–¹å¼:</label>
                            <select id="node-notification-type" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="email" ${node.data('notification_type') === 'email' ? 'selected' : ''}>é‚®ä»¶</option>
                                <option value="sms" ${node.data('notification_type') === 'sms' ? 'selected' : ''}>çŸ­ä¿¡</option>
                                <option value="system" ${node.data('notification_type') === 'system' ? 'selected' : ''}>ç³»ç»Ÿæ¶ˆæ¯</option>
                            </select>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px;">é€šçŸ¥å¯¹è±¡:</label>
                            <input id="node-notification-recipient" type="text" value="${node.data('notification_recipient') || ''}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" />
                        </div>
                    ` : ''}
                    <div style="margin-top: 20px; text-align: right;">
                        <button onclick="saveNodeConfig()" style="padding: 8px 16px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">ä¿å­˜</button>
                        <button onclick="closeNodeConfigDialog()" style="padding: 8px 16px; background: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">å–æ¶ˆ</button>
                    </div>
                </div>
            `;
            
            // ä½¿ç”¨Element Plusçš„å¯¹è¯æ¡†ï¼ˆå¦‚æœå¯ç”¨ï¼‰æˆ–ç®€å•çš„æ¨¡æ€æ¡†
            if (typeof ElementPlus !== 'undefined') {
                // ä½¿ç”¨Element Pluså¯¹è¯æ¡†
                ElementPlus.ElMessageBox.alert(dialogHtml, 'èŠ‚ç‚¹é…ç½®', {
                    dangerouslyUseHTMLString: true,
                    showCancelButton: true,
                    confirmButtonText: 'ä¿å­˜',
                    cancelButtonText: 'å–æ¶ˆ',
                    beforeClose: (action, instance, done) => {
                        if (action === 'confirm') {
                            saveNodeConfig();
                            done();
                        } else {
                            done();
                        }
                    }
                });
            } else {
                // ç®€å•çš„æ¨¡æ€æ¡†
                const modal = document.createElement('div');
                modal.id = 'node-config-modal';
                modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;';
                modal.innerHTML = `
                    <div style="background: white; padding: 0; border-radius: 8px; max-width: 500px; width: 90%; max-height: 90%; overflow-y: auto;">
                        ${dialogHtml}
                    </div>
                `;
                document.body.appendChild(modal);
            }
        }
        
        function saveNodeConfig() {
            if (!currentNode) return;
            
            const label = document.getElementById('node-label')?.value || '';
            const assignee = document.getElementById('node-assignee')?.value || '';
            const duration = document.getElementById('node-duration')?.value || '';
            const condition = document.getElementById('node-condition')?.value || '';
            const approver = document.getElementById('node-approver')?.value || '';
            const approvalLevel = document.getElementById('node-approval-level')?.value || '';
            const notificationType = document.getElementById('node-notification-type')?.value || '';
            const notificationRecipient = document.getElementById('node-notification-recipient')?.value || '';
            
            currentNode.data('label', label);
            if (assignee) currentNode.data('assignee', assignee);
            if (duration) currentNode.data('duration', duration);
            if (condition) currentNode.data('condition', condition);
            if (approver) currentNode.data('approver', approver);
            if (approvalLevel) currentNode.data('approval_level', approvalLevel);
            if (notificationType) currentNode.data('notification_type', notificationType);
            if (notificationRecipient) currentNode.data('notification_recipient', notificationRecipient);
            
            closeNodeConfigDialog();
        }
        
        function closeNodeConfigDialog() {
            const modal = document.getElementById('node-config-modal');
            if (modal) {
                modal.remove();
            }
            currentNode = null;
        }

        // è¿çº¿é…ç½®
        cy.on('dbltap', 'edge', (evt) => {
            const edge = evt.target;
            const label = prompt('è¿çº¿æ ‡ç­¾:', edge.data('label') || '');
            if (label !== null) {
                edge.data('label', label);
            }
        });

        async function saveWorkflow() {
            const workflowName = prompt('æµç¨‹åç§°:', 'æ–°å»ºæµç¨‹') || 'æ–°å»ºæµç¨‹';
            const workflowDescription = prompt('æµç¨‹æè¿°:', '') || '';
            
            // å°†èŠ‚ç‚¹å’Œè¾¹è½¬æ¢ä¸ºæµç¨‹é˜¶æ®µ
            const stages = [];
            cy.nodes().forEach((node, index) => {
                const stage = {
                    stage_name: node.data('label'),
                    stage_order: index + 1,
                    stage_type: node.data('type'),
                    assignee: node.data('assignee'),
                    estimated_duration: node.data('duration') ? parseFloat(node.data('duration')) : null,
                    condition: node.data('condition'),
                    properties: node.data('properties') || {}
                };
                stages.push(stage);
            });
            
            const workflow = {
                name: workflowName,
                description: workflowDescription,
                process_type: 'custom',
                stages: stages
            };
            
            try {
                const response = await axios.post('/api/process/define', workflow);
                if (response.data && response.data.process_id) {
                    alert('âœ… æµç¨‹å·²ä¿å­˜ï¼\næµç¨‹ID: ' + response.data.process_id);
                } else {
                    throw new Error('ä¿å­˜å¤±è´¥ï¼šæœªè¿”å›æµç¨‹ID');
                }
            } catch (error) {
                console.error('ä¿å­˜æµç¨‹:', workflow);
                alert('ä¿å­˜å¤±è´¥: ' + (error.response?.data?.detail || error.message) + '\næµç¨‹æ•°æ®å·²è¾“å‡ºåˆ°æ§åˆ¶å°');
            }
        }

        async function loadWorkflow() {
            const processId = prompt('è¯·è¾“å…¥æµç¨‹ID:', '');
            if (!processId) return;
            
            try {
                const response = await axios.get(`/api/process/define/${processId}`);
                if (response.data) {
                    // å°†æµç¨‹é˜¶æ®µè½¬æ¢ä¸ºèŠ‚ç‚¹å’Œè¾¹
                    const workflow = response.data;
                    const nodes = workflow.stages?.map((stage, index) => ({
                        id: `node_${index + 1}`,
                        label: stage.stage_name || stage.name,
                        type: stage.stage_type || 'task',
                        position: { x: 250, y: 50 + index * 100 },
                        assignee: stage.assignee,
                        duration: stage.estimated_duration,
                        condition: stage.condition
                    })) || [];
                    
                    const edges = [];
                    for (let i = 0; i < nodes.length - 1; i++) {
                        edges.push({
                            id: `edge_${i}_${i+1}`,
                            source: nodes[i].id,
                            target: nodes[i+1].id
                        });
                    }
                    
                    loadWorkflowToCanvas({ nodes, edges });
                    alert('âœ… æµç¨‹åŠ è½½æˆåŠŸï¼');
                } else {
                    throw new Error('åŠ è½½å¤±è´¥ï¼šæœªè¿”å›æ•°æ®');
                }
            } catch (error) {
                alert('åŠ è½½å¤±è´¥: ' + (error.response?.data?.detail || error.message));
            }
        }

        function loadWorkflowToCanvas(workflow) {
            cy.elements().remove();
            nodeCounter = 0;
            
            // åŠ è½½èŠ‚ç‚¹
            workflow.nodes.forEach(nodeData => {
                cy.add({
                    group: 'nodes',
                    data: {
                        id: nodeData.id,
                        label: nodeData.label,
                        type: nodeData.type,
                        assignee: nodeData.assignee,
                        duration: nodeData.duration,
                        condition: nodeData.condition,
                        properties: nodeData.properties || {}
                    },
                    position: nodeData.position
                });
            });
            
            // åŠ è½½è¿çº¿
            workflow.edges.forEach(edgeData => {
                cy.add({
                    group: 'edges',
                    data: {
                        id: edgeData.id,
                        source: edgeData.source,
                        target: edgeData.target,
                        label: edgeData.label || '',
                        condition: edgeData.condition
                    }
                });
            });
            
            cy.layout({ name: 'dagre', rankDir: 'TB' }).run();
            saveHistory(); // ä¿å­˜åŠ è½½åçš„çŠ¶æ€
        }
        
        // æµç¨‹é¢„è§ˆåŠŸèƒ½
        function previewWorkflow() {
            const nodes = cy.nodes();
            const edges = cy.edges();
            
            if (nodes.length === 0) {
                alert('æµç¨‹ä¸ºç©ºï¼Œæ— æ³•é¢„è§ˆ');
                return;
            }
            
            let previewHtml = '<div style="padding: 20px;"><h3>æµç¨‹é¢„è§ˆ</h3><ol>';
            nodes.forEach((node, index) => {
                previewHtml += `<li>${node.data('label')} (${getNodeTypeName(node.data('type'))})</li>`;
            });
            previewHtml += '</ol></div>';
            
            ElementPlus.ElMessageBox.alert(previewHtml, 'æµç¨‹é¢„è§ˆ', {
                dangerouslyUseHTMLString: true,
                confirmButtonText: 'ç¡®å®š'
            });
        }
        
        // æµç¨‹æ¨¡æ‹Ÿæ‰§è¡Œ
        function simulateWorkflow() {
            const nodes = cy.nodes();
            const startNodes = nodes.filter(node => node.data('type') === 'start');
            
            if (startNodes.length === 0) {
                alert('æµç¨‹ä¸­æ²¡æœ‰å¼€å§‹èŠ‚ç‚¹ï¼Œæ— æ³•æ¨¡æ‹Ÿæ‰§è¡Œ');
                return;
            }
            
            if (startNodes.length > 1) {
                alert('æµç¨‹ä¸­æœ‰å¤šä¸ªå¼€å§‹èŠ‚ç‚¹ï¼Œæ— æ³•æ¨¡æ‹Ÿæ‰§è¡Œ');
                return;
            }
            
            // ç®€å•çš„æ¨¡æ‹Ÿæ‰§è¡Œï¼ˆæŒ‰èŠ‚ç‚¹é¡ºåºï¼‰
            const executionPath = [];
            const visited = new Set();
            
            function traverse(nodeId) {
                if (visited.has(nodeId)) return;
                visited.add(nodeId);
                
                const node = cy.getElementById(nodeId);
                executionPath.push({
                    step: executionPath.length + 1,
                    node: node.data('label'),
                    type: node.data('type')
                });
                
                // éå†åç»­èŠ‚ç‚¹
                const outgoing = node.outgoers('node');
                outgoing.forEach(target => {
                    traverse(target.id());
                });
            }
            
            traverse(startNodes[0].id());
            
            let simulationHtml = '<div style="padding: 20px;"><h3>æµç¨‹æ¨¡æ‹Ÿæ‰§è¡Œ</h3><ol>';
            executionPath.forEach(item => {
                simulationHtml += `<li>æ­¥éª¤${item.step}: ${item.node} (${getNodeTypeName(item.type)})</li>`;
            });
            simulationHtml += '</ol></div>';
            
            ElementPlus.ElMessageBox.alert(simulationHtml, 'æµç¨‹æ¨¡æ‹Ÿæ‰§è¡Œ', {
                dangerouslyUseHTMLString: true,
                confirmButtonText: 'ç¡®å®š'
            });
        }

        function validateWorkflow() {
            const nodes = cy.nodes();
            const edges = cy.edges();
            const errors = [];
            const warnings = [];
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å¼€å§‹èŠ‚ç‚¹
            const startNodes = nodes.filter(node => node.data('type') === 'start');
            if (startNodes.length === 0) {
                errors.push('âŒ ç¼ºå°‘å¼€å§‹èŠ‚ç‚¹');
            } else if (startNodes.length > 1) {
                errors.push('âŒ åªèƒ½æœ‰ä¸€ä¸ªå¼€å§‹èŠ‚ç‚¹');
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰ç»“æŸèŠ‚ç‚¹
            const endNodes = nodes.filter(node => node.data('type') === 'end');
            if (endNodes.length === 0) {
                errors.push('âŒ ç¼ºå°‘ç»“æŸèŠ‚ç‚¹');
            }
            
            // æ£€æŸ¥å­¤ç«‹èŠ‚ç‚¹
            nodes.forEach(node => {
                const incoming = node.incomers().length;
                const outgoing = node.outgoers().length;
                
                if (node.data('type') !== 'start' && incoming === 0) {
                    warnings.push(`âš ï¸ èŠ‚ç‚¹ "${node.data('label')}" æ²¡æœ‰è¾“å…¥è¿çº¿`);
                }
                if (node.data('type') !== 'end' && outgoing === 0) {
                    warnings.push(`âš ï¸ èŠ‚ç‚¹ "${node.data('label')}" æ²¡æœ‰è¾“å‡ºè¿çº¿`);
                }
            });
            
            // æ£€æŸ¥æ¡ä»¶èŠ‚ç‚¹çš„æ¡ä»¶è¡¨è¾¾å¼
            nodes.filter(node => node.data('type') === 'condition').forEach(node => {
                if (!node.data('condition')) {
                    warnings.push(`âš ï¸ æ¡ä»¶èŠ‚ç‚¹ "${node.data('label')}" ç¼ºå°‘æ¡ä»¶è¡¨è¾¾å¼`);
                }
            });
            
            // æ£€æŸ¥ä»»åŠ¡èŠ‚ç‚¹çš„å¿…å¡«å­—æ®µ
            nodes.filter(node => node.data('type') === 'task').forEach(node => {
                if (!node.data('assignee')) {
                    warnings.push(`âš ï¸ ä»»åŠ¡èŠ‚ç‚¹ "${node.data('label')}" ç¼ºå°‘è´Ÿè´£äºº`);
                }
            });
            
            // æ£€æŸ¥å¾ªç¯å¼•ç”¨
            const visited = new Set();
            const recStack = new Set();
            
            function hasCycle(nodeId) {
                if (recStack.has(nodeId)) return true;
                if (visited.has(nodeId)) return false;
                
                visited.add(nodeId);
                recStack.add(nodeId);
                
                const node = cy.getElementById(nodeId);
                const outgoing = node.outgoers('node');
                
                for (let target of outgoing) {
                    if (hasCycle(target.id())) return true;
                }
                
                recStack.delete(nodeId);
                return false;
            }
            
            nodes.forEach(node => {
                if (!visited.has(node.id()) && hasCycle(node.id())) {
                    errors.push('âŒ æ£€æµ‹åˆ°å¾ªç¯å¼•ç”¨');
                }
            });
            
            // æ˜¾ç¤ºéªŒè¯ç»“æœ
            let message = '';
            if (errors.length > 0) {
                message += 'éªŒè¯å¤±è´¥ï¼š\n\n' + errors.join('\n');
            } else {
                message += 'âœ… æµç¨‹éªŒè¯é€šè¿‡ï¼\n';
            }
            
            if (warnings.length > 0) {
                message += '\nè­¦å‘Šï¼š\n' + warnings.join('\n');
            }
            
            alert(message);
            
            return errors.length === 0;
        }

        async function publishWorkflow() {
            // å…ˆéªŒè¯æµç¨‹
            if (!validateWorkflow()) {
                alert('è¯·å…ˆä¿®å¤æµç¨‹é”™è¯¯åå†å‘å¸ƒï¼');
                return;
            }
            
            if (!confirm('ç¡®å®šè¦å‘å¸ƒæµç¨‹å—ï¼Ÿå‘å¸ƒåæµç¨‹å°†ç”Ÿæ•ˆã€‚')) {
                return;
            }
            
            const workflowName = prompt('æµç¨‹åç§°:', 'æ–°å»ºæµç¨‹') || 'æ–°å»ºæµç¨‹';
            const workflowDescription = prompt('æµç¨‹æè¿°:', '') || '';
            
            // å°†èŠ‚ç‚¹å’Œè¾¹è½¬æ¢ä¸ºæµç¨‹é˜¶æ®µ
            const stages = [];
            const nodeMap = new Map();
            
            cy.nodes().forEach((node, index) => {
                const stage = {
                    stage_name: node.data('label'),
                    stage_order: index + 1,
                    stage_type: node.data('type'),
                    assignee: node.data('assignee'),
                    estimated_duration: node.data('duration') ? parseFloat(node.data('duration')) : null,
                    condition: node.data('condition'),
                    properties: node.data('properties') || {}
                };
                stages.push(stage);
                nodeMap.set(node.id(), stage);
            });
            
            const workflow = {
                name: workflowName,
                description: workflowDescription,
                process_type: 'custom',
                stages: stages,
                status: 'published'
            };
            
            try {
                const response = await axios.post('/api/process/define', workflow);
                if (response.data && response.data.process_id) {
                    alert('âœ… æµç¨‹å·²å‘å¸ƒï¼\næµç¨‹ID: ' + response.data.process_id);
                } else {
                    throw new Error('å‘å¸ƒå¤±è´¥ï¼šæœªè¿”å›æµç¨‹ID');
                }
            } catch (error) {
                console.error('å‘å¸ƒæµç¨‹:', workflow);
                alert('å‘å¸ƒå¤±è´¥: ' + (error.response?.data?.detail || error.message) + '\næµç¨‹æ•°æ®å·²è¾“å‡ºåˆ°æ§åˆ¶å°');
            }
        }
        
        // åŠ è½½æµç¨‹æ¨¡æ¿
        function loadTemplate(templateType) {
            if (!confirm('åŠ è½½æ¨¡æ¿å°†æ¸…ç©ºå½“å‰ç”»å¸ƒï¼Œç¡®å®šç»§ç»­å—ï¼Ÿ')) {
                return;
            }
            
            const templates = {
                'standard': {
                    nodes: [
                        { id: 'start', label: 'å¼€å§‹', type: 'start', position: { x: 250, y: 50 } },
                        { id: 'order', label: 'è®¢å•ç¡®è®¤', type: 'task', position: { x: 250, y: 150 } },
                        { id: 'plan', label: 'ç”Ÿäº§è®¡åˆ’', type: 'task', position: { x: 250, y: 250 } },
                        { id: 'procure', label: 'é‡‡è´­', type: 'task', position: { x: 150, y: 350 } },
                        { id: 'produce', label: 'ç”Ÿäº§', type: 'task', position: { x: 250, y: 350 } },
                        { id: 'quality', label: 'è´¨æ£€', type: 'task', position: { x: 350, y: 350 } },
                        { id: 'delivery', label: 'äº¤ä»˜', type: 'task', position: { x: 250, y: 450 } },
                        { id: 'end', label: 'ç»“æŸ', type: 'end', position: { x: 250, y: 550 } }
                    ],
                    edges: [
                        { source: 'start', target: 'order' },
                        { source: 'order', target: 'plan' },
                        { source: 'plan', target: 'procure' },
                        { source: 'plan', target: 'produce' },
                        { source: 'procure', target: 'produce' },
                        { source: 'produce', target: 'quality' },
                        { source: 'quality', target: 'delivery' },
                        { source: 'delivery', target: 'end' }
                    ]
                },
                'production': {
                    nodes: [
                        { id: 'start', label: 'å¼€å§‹', type: 'start', position: { x: 250, y: 50 } },
                        { id: 'prepare', label: 'ç”Ÿäº§å‡†å¤‡', type: 'task', position: { x: 250, y: 150 } },
                        { id: 'execute', label: 'ç”Ÿäº§æ‰§è¡Œ', type: 'task', position: { x: 250, y: 250 } },
                        { id: 'check', label: 'è´¨é‡æ£€æŸ¥', type: 'condition', position: { x: 250, y: 350 } },
                        { id: 'pass', label: 'åˆæ ¼', type: 'task', position: { x: 150, y: 450 } },
                        { id: 'fail', label: 'ä¸åˆæ ¼', type: 'task', position: { x: 350, y: 450 } },
                        { id: 'end', label: 'ç»“æŸ', type: 'end', position: { x: 250, y: 550 } }
                    ],
                    edges: [
                        { source: 'start', target: 'prepare' },
                        { source: 'prepare', target: 'execute' },
                        { source: 'execute', target: 'check' },
                        { source: 'check', target: 'pass', label: 'æ˜¯' },
                        { source: 'check', target: 'fail', label: 'å¦' },
                        { source: 'pass', target: 'end' },
                        { source: 'fail', target: 'execute' }
                    ]
                },
                'procurement': {
                    nodes: [
                        { id: 'start', label: 'å¼€å§‹', type: 'start', position: { x: 250, y: 50 } },
                        { id: 'request', label: 'é‡‡è´­ç”³è¯·', type: 'task', position: { x: 250, y: 150 } },
                        { id: 'approve', label: 'å®¡æ‰¹', type: 'condition', position: { x: 250, y: 250 } },
                        { id: 'order', label: 'ä¸‹å•', type: 'task', position: { x: 150, y: 350 } },
                        { id: 'reject', label: 'é©³å›', type: 'task', position: { x: 350, y: 350 } },
                        { id: 'receive', label: 'æ”¶è´§', type: 'task', position: { x: 150, y: 450 } },
                        { id: 'end', label: 'ç»“æŸ', type: 'end', position: { x: 250, y: 550 } }
                    ],
                    edges: [
                        { source: 'start', target: 'request' },
                        { source: 'request', target: 'approve' },
                        { source: 'approve', target: 'order', label: 'é€šè¿‡' },
                        { source: 'approve', target: 'reject', label: 'é©³å›' },
                        { source: 'order', target: 'receive' },
                        { source: 'receive', target: 'end' },
                        { source: 'reject', target: 'end' }
                    ]
                }
            };
            
            const template = templates[templateType];
            if (template) {
                loadWorkflowToCanvas({ nodes: template.nodes, edges: template.edges });
                alert('æ¨¡æ¿åŠ è½½æˆåŠŸï¼');
            }
        }
        
        // ==================== æ™ºèƒ½å·¥ä½œè®¡åˆ’é›†æˆ ====================
        
        async function loadTasksFromPlanning() {
            try {
                const response = await axios.get('/api/super-agent/task/statistics');
                const tasks = response.data.pending_tasks || [];
                
                if (tasks.length === 0) {
                    alert('æš‚æ— å¾…å¤„ç†çš„ä»»åŠ¡è®¡åˆ’');
                    return;
                }
                
                // æ˜¾ç¤ºä»»åŠ¡é€‰æ‹©å¯¹è¯æ¡†
                const taskList = tasks.map((task, index) => 
                    `${index + 1}. ${task.name || task.description || 'æœªå‘½åä»»åŠ¡'}`
                ).join('\n');
                
                const selectedIndex = prompt(`è¯·é€‰æ‹©è¦å¯¼å…¥çš„ä»»åŠ¡ï¼ˆè¾“å…¥åºå·ï¼‰:\n\n${taskList}`, '1');
                if (selectedIndex === null) return;
                
                const taskIndex = parseInt(selectedIndex) - 1;
                if (taskIndex < 0 || taskIndex >= tasks.length) {
                    alert('æ— æ•ˆçš„é€‰æ‹©');
                    return;
                }
                
                const selectedTask = tasks[taskIndex];
                
                // å°†ä»»åŠ¡è½¬æ¢ä¸ºå·¥ä½œæµèŠ‚ç‚¹
                if (selectedTask.steps && selectedTask.steps.length > 0) {
                    const nodes = [];
                    const edges = [];
                    
                    // åˆ›å»ºå¼€å§‹èŠ‚ç‚¹
                    const startId = `start_${Date.now()}`;
                    nodes.push({
                        id: startId,
                        label: 'å¼€å§‹',
                        type: 'start',
                        position: { x: 250, y: 50 }
                    });
                    
                    // åˆ›å»ºä»»åŠ¡æ­¥éª¤èŠ‚ç‚¹
                    let prevId = startId;
                    selectedTask.steps.forEach((step, index) => {
                        const nodeId = `task_${Date.now()}_${index}`;
                        nodes.push({
                            id: nodeId,
                            label: step.name || step.description || `æ­¥éª¤${index + 1}`,
                            type: 'task',
                            position: { x: 250, y: 150 + index * 100 }
                        });
                        
                        edges.push({
                            source: prevId,
                            target: nodeId
                        });
                        
                        prevId = nodeId;
                    });
                    
                    // åˆ›å»ºç»“æŸèŠ‚ç‚¹
                    const endId = `end_${Date.now()}`;
                    nodes.push({
                        id: endId,
                        label: 'ç»“æŸ',
                        type: 'end',
                        position: { x: 250, y: 150 + selectedTask.steps.length * 100 }
                    });
                    
                    edges.push({
                        source: prevId,
                        target: endId
                    });
                    
                    // åŠ è½½åˆ°ç”»å¸ƒ
                    loadWorkflowToCanvas({ nodes, edges });
                    alert(`âœ… å·²å¯¼å…¥ä»»åŠ¡: ${selectedTask.name || 'æœªå‘½åä»»åŠ¡'}\nå…±${selectedTask.steps.length}ä¸ªæ­¥éª¤`);
                } else {
                    // å•ä¸ªä»»åŠ¡èŠ‚ç‚¹
                    const nodeId = `task_${Date.now()}`;
                    cy.add({
                        group: 'nodes',
                        data: {
                            id: nodeId,
                            label: selectedTask.name || selectedTask.description || 'ä»»åŠ¡',
                            type: 'task'
                        },
                        position: { x: 250, y: 150 }
                    });
                    alert(`âœ… å·²æ·»åŠ ä»»åŠ¡èŠ‚ç‚¹: ${selectedTask.name || 'æœªå‘½åä»»åŠ¡'}`);
                }
            } catch (error) {
                console.error('åŠ è½½ä»»åŠ¡å¤±è´¥:', error);
                alert('åŠ è½½ä»»åŠ¡å¤±è´¥: ' + (error.response?.data?.detail || error.message));
            }
        }
        
        async function showTaskPlanningPanel() {
            const panel = document.getElementById('task-planning-panel');
            const container = document.getElementById('tasks-list-container');
            
            if (panel.style.display === 'none') {
                try {
                    const response = await axios.get('/api/super-agent/task/statistics');
                    const tasks = response.data.pending_tasks || [];
                    
                    if (tasks.length === 0) {
                        container.innerHTML = '<p style="color: #999; font-size: 12px;">æš‚æ— å¾…å¤„ç†ä»»åŠ¡</p>';
                    } else {
                        container.innerHTML = tasks.map((task, index) => `
                            <div style="padding: 8px; margin-bottom: 5px; background: #fff; border-radius: 4px; font-size: 12px;">
                                <strong>${task.name || 'æœªå‘½åä»»åŠ¡'}</strong><br>
                                <span style="color: #666;">${task.description || ''}</span>
                                <button onclick="importTaskToWorkflow(${index})" style="float: right; padding: 2px 8px; font-size: 11px;">å¯¼å…¥</button>
                            </div>
                        `).join('');
                    }
                    
                    panel.style.display = 'block';
                } catch (error) {
                    container.innerHTML = '<p style="color: #f44336; font-size: 12px;">åŠ è½½å¤±è´¥: ' + error.message + '</p>';
                    panel.style.display = 'block';
                }
            } else {
                panel.style.display = 'none';
            }
        }
        
        async function createTaskFromMemo() {
            try {
                // è·å–å¤‡å¿˜å½•åˆ—è¡¨
                const response = await axios.get('/api/super-agent/memo/list');
                const memos = response.data.memos || [];
                
                if (memos.length === 0) {
                    alert('æš‚æ— å¤‡å¿˜å½•');
                    return;
                }
                
                // æ˜¾ç¤ºå¤‡å¿˜å½•é€‰æ‹©å¯¹è¯æ¡†
                const memoList = memos.map((memo, index) => 
                    `${index + 1}. ${memo.content?.substring(0, 50) || 'ç©ºå¤‡å¿˜å½•'}...`
                ).join('\n');
                
                const selectedIndex = prompt(`è¯·é€‰æ‹©è¦åˆ›å»ºä»»åŠ¡çš„å¤‡å¿˜å½•ï¼ˆè¾“å…¥åºå·ï¼‰:\n\n${memoList}`, '1');
                if (selectedIndex === null) return;
                
                const memoIndex = parseInt(selectedIndex) - 1;
                if (memoIndex < 0 || memoIndex >= memos.length) {
                    alert('æ— æ•ˆçš„é€‰æ‹©');
                    return;
                }
                
                const selectedMemo = memos[memoIndex];
                
                // ä»å¤‡å¿˜å½•æå–ä»»åŠ¡
                const taskResponse = await axios.post('/api/super-agent/task/extract', {
                    memo_id: selectedMemo.id,
                    memo_content: selectedMemo.content
                });
                
                if (taskResponse.data.tasks && taskResponse.data.tasks.length > 0) {
                    // åˆ›å»ºä»»åŠ¡èŠ‚ç‚¹
                    taskResponse.data.tasks.forEach((task, index) => {
                        const nodeId = `task_memo_${Date.now()}_${index}`;
                        cy.add({
                            group: 'nodes',
                            data: {
                                id: nodeId,
                                label: task.name || task.description || 'ä»»åŠ¡',
                                type: 'task'
                            },
                            position: { x: 250 + index * 150, y: 150 }
                        });
                    });
                    
                    alert(`âœ… å·²ä»å¤‡å¿˜å½•åˆ›å»º${taskResponse.data.tasks.length}ä¸ªä»»åŠ¡èŠ‚ç‚¹`);
                } else {
                    alert('æœªèƒ½ä»å¤‡å¿˜å½•ä¸­æå–ä»»åŠ¡');
                }
            } catch (error) {
                console.error('åˆ›å»ºä»»åŠ¡å¤±è´¥:', error);
                alert('åˆ›å»ºä»»åŠ¡å¤±è´¥: ' + (error.response?.data?.detail || error.message));
            }
        }
        
        // ==================== è¯•ç®—åŠŸèƒ½é›†æˆ ====================
        
        async function showTrialBalancePanel() {
            const panel = document.getElementById('trial-balance-panel');
            const content = document.getElementById('trial-balance-content');
            
            if (panel.style.display === 'none') {
                content.innerHTML = `
                    <h4 style="margin-bottom: 15px; font-size: 14px;">è¯•ç®—åŠŸèƒ½</h4>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 12px;">è¯•ç®—ç±»å‹:</label>
                            <select id="trial-type" style="width: 100%; padding: 5px; font-size: 12px;">
                                <option value="daily_delivery">æ¯æ—¥äº¤ä»˜é‡</option>
                                <option value="production_capacity">ç”Ÿäº§äº§èƒ½</option>
                                <option value="cost_breakdown">æˆæœ¬åˆ†è§£</option>
                                <option value="material_requirement">ç‰©æ–™éœ€æ±‚</option>
                                <option value="delivery_schedule">äº¤ä»˜è®¡åˆ’</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 12px;">ç›®æ ‡å€¼:</label>
                            <input type="number" id="trial-target" placeholder="è¾“å…¥ç›®æ ‡å€¼" style="width: 100%; padding: 5px; font-size: 12px;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 12px;">äº§å“ID (å¯é€‰):</label>
                            <input type="number" id="trial-product-id" placeholder="äº§å“ID" style="width: 100%; padding: 5px; font-size: 12px;">
                        </div>
                        <button class="btn btn-primary" onclick="executeTrialBalance()" style="width: 100%; font-size: 12px;">æ‰§è¡Œè¯•ç®—</button>
                    </div>
                    <div id="trial-result" style="margin-top: 15px; padding: 10px; background: #fff; border-radius: 4px; display: none; font-size: 12px;"></div>
                `;
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }
        
        async function executeTrialBalance() {
            const trialType = document.getElementById('trial-type').value;
            const targetValue = parseFloat(document.getElementById('trial-target').value);
            const productId = document.getElementById('trial-product-id').value;
            const resultDiv = document.getElementById('trial-result');
            
            if (!targetValue || isNaN(targetValue)) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„ç›®æ ‡å€¼');
                return;
            }
            
            try {
                resultDiv.style.display = 'block';
                resultDiv.innerHTML = '<p>æ­£åœ¨è®¡ç®—...</p>';
                
                const response = await axios.post('/api/trial-balance/custom', {
                    calculation_type: trialType,
                    target_value: targetValue,
                    parameters: {
                        product_id: productId ? parseInt(productId) : null
                    }
                });
                
                if (response.data.success) {
                    const result = response.data.result;
                    let resultHtml = '<h5 style="margin-bottom: 10px;">è¯•ç®—ç»“æœ:</h5>';
                    
                    if (trialType === 'daily_delivery') {
                        resultHtml += `
                            <p><strong>ç›®æ ‡å‘¨è¥ä¸šé¢:</strong> Â¥${result.target_weekly_revenue || targetValue}</p>
                            <p><strong>æ¯æ—¥äº¤ä»˜é‡:</strong> ${result.daily_quantity || 'N/A'} ä»¶</p>
                            <p><strong>æ€»éœ€æ±‚é‡:</strong> ${result.total_quantity_needed || 'N/A'} ä»¶</p>
                            <p><strong>å¯è¡Œæ€§:</strong> ${result.feasibility || 'N/A'}</p>
                        `;
                        if (result.recommendations) {
                            resultHtml += '<p><strong>å»ºè®®:</strong></p><ul>';
                            result.recommendations.forEach(rec => {
                                resultHtml += `<li>${rec}</li>`;
                            });
                            resultHtml += '</ul>';
                        }
                    } else {
                        resultHtml += '<pre>' + JSON.stringify(result, null, 2) + '</pre>';
                    }
                    
                    resultDiv.innerHTML = resultHtml;
                } else {
                    resultDiv.innerHTML = '<p style="color: #f44336;">è¯•ç®—å¤±è´¥</p>';
                }
            } catch (error) {
                console.error('è¯•ç®—å¤±è´¥:', error);
                resultDiv.innerHTML = '<p style="color: #f44336;">è¯•ç®—å¤±è´¥: ' + (error.response?.data?.detail || error.message) + '</p>';
            }
        }
        
        async function calculateDailyDelivery() {
            const targetRevenue = prompt('è¯·è¾“å…¥å‘¨ç›®æ ‡è¥ä¸šé¢:', '100000');
            if (!targetRevenue) return;
            
            try {
                const response = await axios.post('/api/trial-balance/daily-delivery', {
                    target_weekly_revenue: parseFloat(targetRevenue)
                });
                
                if (response.data.success) {
                    const result = response.data.result;
                    alert(`è¯•ç®—ç»“æœ:\næ¯æ—¥äº¤ä»˜é‡: ${result.daily_quantity} ä»¶\nå¯è¡Œæ€§: ${result.feasibility}`);
                }
            } catch (error) {
                alert('è¯•ç®—å¤±è´¥: ' + (error.response?.data?.detail || error.message));
            }
        }
        
        async function calculateProductionCapacity() {
            const target = prompt('è¯·è¾“å…¥ç›®æ ‡äº§é‡:', '1000');
            if (!target) return;
            
            try {
                const response = await axios.post('/api/trial-balance/custom', {
                    calculation_type: 'production_capacity',
                    target_value: parseFloat(target),
                    parameters: {}
                });
                
                if (response.data.success) {
                    alert('äº§èƒ½è¯•ç®—å®Œæˆï¼Œè¯·æŸ¥çœ‹è¯•ç®—é¢æ¿');
                    showTrialBalancePanel();
                    executeTrialBalance();
                }
            } catch (error) {
                alert('è¯•ç®—å¤±è´¥: ' + (error.response?.data?.detail || error.message));
            }
        }
        
        async function calculateCostBreakdown() {
            const target = prompt('è¯·è¾“å…¥ç›®æ ‡æˆæœ¬:', '50000');
            if (!target) return;
            
            try {
                const response = await axios.post('/api/trial-balance/custom', {
                    calculation_type: 'cost_breakdown',
                    target_value: parseFloat(target),
                    parameters: {}
                });
                
                if (response.data.success) {
                    alert('æˆæœ¬åˆ†è§£è¯•ç®—å®Œæˆï¼Œè¯·æŸ¥çœ‹è¯•ç®—é¢æ¿');
                    showTrialBalancePanel();
                    executeTrialBalance();
                }
            } catch (error) {
                alert('è¯•ç®—å¤±è´¥: ' + (error.response?.data?.detail || error.message));
            }
        }
    </script>
</body>
</html>

