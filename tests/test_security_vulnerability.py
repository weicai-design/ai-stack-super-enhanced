"""
安全漏洞测试
测试系统的安全防护能力、漏洞检测和防护机制
"""

import unittest
import asyncio
import time
import json
import base64
import hashlib
import hmac
from datetime import datetime, timedelta
from unittest.mock import Mock, patch, MagicMock
import threading
import concurrent.futures
import re

from ..core.enhanced_circuit_breaker_manager import enhanced_integration_manager
from ..core.data_persistence_backup import create_data_manager
from ..config.enhanced_circuit_breaker_config import ServiceCategory


class TestInjectionAttacks(unittest.TestCase):
    """注入攻击测试"""
    
    def setUp(self):
        """测试准备"""
        self.data_manager = create_data_manager("security_test")
        enhanced_integration_manager.register_service(
            "injection_protection_service", ServiceCategory.API_SERVICE
        )
    
    def tearDown(self):
        """测试清理"""
        import shutil
        import os
        if os.path.exists("security_test"):
            shutil.rmtree("security_test")
    
    def test_sql_injection_protection(self):
        """测试SQL注入防护"""
        # 模拟SQL注入攻击向量
        injection_vectors = [
            "'; DROP TABLE users; --",
            "1' OR '1'='1",
            "'; EXEC xp_cmdshell('format c:'); --",
            "UNION SELECT username, password FROM users",
            "'; UPDATE users SET password='hacked' WHERE username='admin'; --"
        ]
        
        def safe_query_processor(query_input):
            """安全的查询处理器"""
            # 输入验证和清理
            if not isinstance(query_input, str):
                raise ValueError("输入必须为字符串")
            
            # 检测SQL注入特征
            sql_injection_patterns = [
                r"(?i)(\bDROP\b|\bDELETE\b|\bUPDATE\b|\bINSERT\b)",
                r"(?i)(\bUNION\b.*\bSELECT\b)",
                r"(?i)(\bEXEC\b|\bEXECUTE\b|\bxp_cmdshell\b)",
                r"['\"].*;.*--",
                r"OR\s+'1'='1'",
                r"';\s*"
            ]
            
            for pattern in sql_injection_patterns:
                if re.search(pattern, query_input):
                    raise SecurityError("检测到SQL注入攻击")
            
            # 安全处理查询
            sanitized_input = re.sub(r"[;'\"\\]+", "", query_input)
            
            @enhanced_integration_manager.enhanced_service_protection("injection_protection_service")
            def process_query(safe_input):
                # 模拟安全查询处理
                return {
                    "query": safe_input,
                    "result": "安全处理完成",
                    "timestamp": datetime.now().isoformat()
                }
            
            return process_query(sanitized_input)
        
        # 测试注入防护
        blocked_attacks = 0
        successful_queries = 0
        
        for vector in injection_vectors:
            try:
                result = safe_query_processor(vector)
                successful_queries += 1
            except SecurityError:
                blocked_attacks += 1
            except Exception:
                # 其他异常也视为防护成功
                blocked_attacks += 1
        
        print(f"\n=== SQL注入防护测试结果 ===")
        print(f"测试攻击向量: {len(injection_vectors)}")
        print(f"成功防护: {blocked_attacks}")
        print(f"成功查询: {successful_queries}")
        print(f"防护成功率: {(blocked_attacks/len(injection_vectors))*100:.2f}%")
        
        # 安全断言
        self.assertEqual(blocked_attacks, len(injection_vectors))  # 所有注入攻击都应被防护
        self.assertEqual(successful_queries, 0)  # 不应有任何注入攻击成功
    
    def test_xss_injection_protection(self):
        """测试XSS注入防护"""
        # 模拟XSS攻击向量
        xss_vectors = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "<body onload=alert('XSS')>"
        ]
        
        def safe_content_processor(content):
            """安全的内容处理器"""
            # XSS检测和清理
            xss_patterns = [
                r"<script[^>]*>.*?</script>",
                r"<img[^>]*onerror[^>]*>",
                r"javascript:",
                r"<svg[^>]*onload[^>]*>",
                r"on\w+\s*=",
                r"<iframe[^>]*>",
                r"<object[^>]*>",
                r"<embed[^>]*>"
            ]
            
            for pattern in xss_patterns:
                if re.search(pattern, content, re.IGNORECASE | re.DOTALL):
                    raise SecurityError("检测到XSS攻击")
            
            # HTML转义
            safe_content = (
                content.replace("<", "&lt;")
                      .replace(">", "&gt;")
                      .replace("'", "&#39;")
                      .replace('"', "&quot;")
            )
            
            @enhanced_integration_manager.enhanced_service_protection("injection_protection_service")
            def process_content(safe_content):
                return {
                    "processed_content": safe_content,
                    "is_safe": True,
                    "timestamp": datetime.now().isoformat()
                }
            
            return process_content(safe_content)
        
        # 测试XSS防护
        blocked_xss = 0
        safe_processed = 0
        
        for vector in xss_vectors:
            try:
                result = safe_content_processor(vector)
                if result["is_safe"]:
                    safe_processed += 1
            except SecurityError:
                blocked_xss += 1
        
        print(f"\n=== XSS注入防护测试结果 ===")
        print(f"测试攻击向量: {len(xss_vectors)}")
        print(f"成功防护: {blocked_xss}")
        print(f"安全处理: {safe_processed}")
        print(f"防护成功率: {(blocked_xss/len(xss_vectors))*100:.2f}%")
        
        # 安全断言
        self.assertGreaterEqual(blocked_xss + safe_processed, len(xss_vectors))


class TestAuthenticationSecurity(unittest.TestCase):
    """认证安全测试"""
    
    def setUp(self):
        """测试准备"""
        enhanced_integration_manager.register_service(
            "auth_security_service", ServiceCategory.API_SERVICE
        )
    
    def test_brute_force_protection(self):
        """测试暴力破解防护"""
        failed_attempts = 0
        successful_logins = 0
        blocked_attempts = 0
        
        def authenticate_user(username, password):
            """用户认证"""
            nonlocal failed_attempts, successful_logins, blocked_attempts
            
            @enhanced_integration_manager.enhanced_service_protection("auth_security_service")
            def perform_authentication():
                # 模拟认证逻辑
                valid_credentials = {
                    "admin": "securepassword123",
                    "user": "userpass456"
                }
                
                # 检查失败次数
                if failed_attempts >= 5:
                    raise SecurityError("账户暂时锁定，请稍后重试")
                
                if username in valid_credentials and valid_credentials[username] == password:
                    return {"success": True, "message": "登录成功"}
                else:
                    failed_attempts += 1
                    raise AuthenticationError("用户名或密码错误")
            
            try:
                result = perform_authentication()
                successful_logins += 1
                return result
            except SecurityError:
                blocked_attempts += 1
                return {"success": False, "message": "账户已锁定"}
            except AuthenticationError:
                return {"success": False, "message": "认证失败"}
        
        # 模拟暴力破解攻击
        attack_passwords = [
            "password", "123456", "admin", "test", "qwerty",
            "letmein", "welcome", "monkey", "password1", "12345678"
        ]
        
        # 尝试暴力破解
        for password in attack_passwords:
            result = authenticate_user("admin", password)
            if not result["success"]:
                print(f"攻击尝试失败: {password}")
        
        # 尝试正确密码
        correct_result = authenticate_user("admin", "securepassword123")
        
        print(f"\n=== 暴力破解防护测试结果 ===")
        print(f"攻击尝试次数: {len(attack_passwords)}")
        print(f"失败认证次数: {failed_attempts}")
        print(f"成功登录次数: {successful_logins}")
        print(f"被阻止尝试: {blocked_attempts}")
        
        # 安全断言
        self.assertFalse(correct_result["success"])  # 正确密码也应被阻止（因为失败次数过多）
        self.assertGreaterEqual(blocked_attempts, 1)  # 至少有一次被阻止的尝试
    
    def test_session_security(self):
        """测试会话安全"""
        sessions = {}
        
        def create_session(user_id, ip_address):
            """创建安全会话"""
            session_id = hashlib.sha256(
                f"{user_id}{time.time()}{ip_address}".encode()
            ).hexdigest()
            
            session_data = {
                "session_id": session_id,
                "user_id": user_id,
                "ip_address": ip_address,
                "created_at": datetime.now(),
                "last_activity": datetime.now(),
                "is_valid": True
            }
            
            sessions[session_id] = session_data
            return session_id
        
        def validate_session(session_id, ip_address):
            """验证会话安全性"""
            if session_id not in sessions:
                raise SecurityError("无效会话")
            
            session = sessions[session_id]
            
            # 检查会话过期（30分钟）
            if datetime.now() - session["last_activity"] > timedelta(minutes=30):
                session["is_valid"] = False
                raise SecurityError("会话已过期")
            
            # 检查IP地址变化
            if session["ip_address"] != ip_address:
                raise SecurityError("会话IP地址不匹配")
            
            # 更新最后活动时间
            session["last_activity"] = datetime.now()
            
            return session
        
        # 测试会话安全
        session_id = create_session(123, "192.168.1.100")
        
        # 正常验证
        try:
            valid_session = validate_session(session_id, "192.168.1.100")
            self.assertTrue(valid_session["is_valid"])
        except SecurityError:
            self.fail("正常会话验证失败")
        
        # IP地址变化测试
        with self.assertRaises(SecurityError):
            validate_session(session_id, "192.168.1.200")
        
        # 过期会话测试
        # 模拟时间流逝
        sessions[session_id]["last_activity"] = datetime.now() - timedelta(minutes=35)
        with self.assertRaises(SecurityError):
            validate_session(session_id, "192.168.1.100")
        
        print(f"\n=== 会话安全测试结果 ===")
        print(f"会话创建: 成功")
        print(f"正常验证: 成功")
        print(f"IP变化检测: 成功")
        print(f"会话过期检测: 成功")


class TestDataSecurity(unittest.TestCase):
    """数据安全测试"""
    
    def setUp(self):
        """测试准备"""
        self.data_manager = create_data_manager("data_security_test", "master_password_123")
    
    def tearDown(self):
        """测试清理"""
        import shutil
        import os
        if os.path.exists("data_security_test"):
            shutil.rmtree("data_security_test")
    
    def test_data_encryption_security(self):
        """测试数据加密安全"""
        # 敏感数据
        sensitive_data = {
            "credit_card": "4111111111111111",
            "ssn": "123-45-6789",
            "api_key": "sk_live_abcdef123456",
            "database_password": "DbPass!2024"
        }
        
        # 加密保存
        success = self.data_manager.save_data(
            sensitive_data, "sensitive.json", ServiceCategory.CONFIGURATION, encrypt=True
        )
        self.assertTrue(success)
        
        # 尝试直接读取加密文件（应该无法解析）
        encrypted_content = self.data_manager.load_data(
            "sensitive.json", ServiceCategory.CONFIGURATION, encrypted=False
        )
        
        # 验证加密内容不是原始数据
        self.assertIsInstance(encrypted_content, bytes)
        self.assertNotIn(b"credit_card", encrypted_content)
        self.assertNotIn(b"4111111111111111", encrypted_content)
        
        # 正确解密
        decrypted_data = self.data_manager.load_data(
            "sensitive.json", ServiceCategory.CONFIGURATION, encrypted=True
        )
        
        # 验证解密数据
        self.assertEqual(decrypted_data["credit_card"], "4111111111111111")
        self.assertEqual(decrypted_data["ssn"], "123-45-6789")
        
        print(f"\n=== 数据加密安全测试结果 ===")
        print(f"数据加密: 成功")
        print(f"加密内容验证: 成功")
        print(f"数据解密: 成功")
    
    def test_data_integrity_protection(self):
        """测试数据完整性保护"""
        # 创建测试数据
        test_data = {
            "transaction_id": "txn_001",
            "amount": 100.50,
            "currency": "USD",
            "timestamp": datetime.now().isoformat()
        }
        
        # 保存数据并生成完整性校验
        success = self.data_manager.save_data(
            test_data, "transaction.json", ServiceCategory.USER_DATA
        )
        self.assertTrue(success)
        
        # 生成数据哈希
        data_hash = hashlib.sha256(
            json.dumps(test_data, sort_keys=True).encode()
        ).hexdigest()
        
        # 保存哈希值
        integrity_data = {
            "data_file": "transaction.json",
            "hash": data_hash,
            "created_at": datetime.now().isoformat()
        }
        
        self.data_manager.save_data(
            integrity_data, "integrity_check.json", ServiceCategory.CONFIGURATION
        )
        
        # 验证数据完整性
        loaded_data = self.data_manager.load_data(
            "transaction.json", ServiceCategory.USER_DATA
        )
        
        current_hash = hashlib.sha256(
            json.dumps(loaded_data, sort_keys=True).encode()
        ).hexdigest()
        
        # 数据未被篡改
        self.assertEqual(current_hash, data_hash)
        
        # 模拟数据篡改
        import os
        file_path = "data_security_test/user_data/transaction.json"
        with open(file_path, 'w') as f:
            tampered_data = test_data.copy()
            tampered_data["amount"] = 1000.00  # 篡改金额
            json.dump(tampered_data, f)
        
        # 重新加载并验证完整性
        tampered_loaded_data = self.data_manager.load_data(
            "transaction.json", ServiceCategory.USER_DATA
        )
        
        tampered_hash = hashlib.sha256(
            json.dumps(tampered_loaded_data, sort_keys=True).encode()
        ).hexdigest()
        
        # 验证哈希不匹配
        self.assertNotEqual(tampered_hash, data_hash)
        
        print(f"\n=== 数据完整性保护测试结果 ===")
        print(f"数据完整性验证: 成功")
        print(f"数据篡改检测: 成功")


class TestAPISecurity(unittest.TestCase):
    """API安全测试"""
    
    def setUp(self):
        """测试准备"""
        enhanced_integration_manager.register_service(
            "api_security_service", ServiceCategory.API_SERVICE
        )
    
    def test_rate_limiting_security(self):
        """测试API限流安全"""
        api_calls = 0
        rate_limited_calls = 0
        
        def protected_api_endpoint():
            """受保护的API端点"""
            nonlocal api_calls, rate_limited_calls
            
            @enhanced_integration_manager.enhanced_service_protection("api_security_service")
            def api_operation():
                api_calls += 1
                
                # 模拟API限流（每秒最多10次调用）
                if api_calls > 10:
                    raise RateLimitError("API调用频率超限")
                
                return {
                    "api_call_id": api_calls,
                    "timestamp": datetime.now().isoformat(),
                    "status": "success"
                }
            
            try:
                return api_operation()
            except RateLimitError:
                rate_limited_calls += 1
                return {"status": "rate_limited", "message": "调用频率超限"}
        
        # 模拟API洪水攻击
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            futures = [executor.submit(protected_api_endpoint) for _ in range(50)]
            results = [f.result() for f in concurrent.futures.as_completed(futures)]
        
        successful_calls = sum(1 for r in results if r["status"] == "success")
        
        print(f"\n=== API限流安全测试结果 ===")
        print(f"总API调用: {len(results)}")
        print(f"成功调用: {successful_calls}")
        print(f"被限流调用: {rate_limited_calls}")
        
        # 安全断言
        self.assertLessEqual(successful_calls, 10)  # 成功调用不应超过限流阈值
        self.assertGreater(rate_limited_calls, 0)  # 应有被限流的调用
    
    def test_input_validation_security(self):
        """测试输入验证安全"""
        def validate_and_process_input(user_input):
            """输入验证和处理"""
            # 基本输入验证
            if not isinstance(user_input, (str, int, float, bool)):
                raise ValidationError("输入类型无效")
            
            if isinstance(user_input, str):
                # 长度限制
                if len(user_input) > 1000:
                    raise ValidationError("输入长度超限")
                
                # 字符白名单
                if not re.match(r'^[a-zA-Z0-9\s\-\.\,\!\?\@\#\$\%\&\*\(\)\+\=\[\]\{\}\|\:;\"\'\<\>\/\\]*$', user_input):
                    raise ValidationError("输入包含非法字符")
            
            @enhanced_integration_manager.enhanced_service_protection("api_security_service")
            def process_valid_input(valid_input):
                return {
                    "processed": True,
                    "input": str(valid_input),
                    "timestamp": datetime.now().isoformat()
                }
            
            return process_valid_input(user_input)
        
        # 测试各种输入
        test_cases = [
            ("正常输入", True),
            ("x" * 1001, False),  # 超长输入
            ("<script>alert('xss')</script>", False),  # XSS攻击
            ("'; DROP TABLE users; --", False),  # SQL注入
            ({"malicious": "object"}, False),  # 复杂对象
            ("正常文本123", True),  # 正常文本
        ]
        
        passed_tests = 0
        failed_tests = 0
        
        for input_data, should_pass in test_cases:
            try:
                result = validate_and_process_input(input_data)
                if should_pass:
                    passed_tests += 1
                else:
                    failed_tests += 1
                    print(f"安全漏洞: 应该失败的输入通过了验证: {input_data}")
            except (ValidationError, SecurityError) as e:
                if not should_pass:
                    passed_tests += 1
                else:
                    failed_tests += 1
                    print(f"误报: 应该通过的输入被拒绝: {input_data}")
        
        print(f"\n=== 输入验证安全测试结果 ===")
        print(f"测试用例: {len(test_cases)}")
        print(f"通过测试: {passed_tests}")
        print(f"失败测试: {failed_tests}")
        print(f"准确率: {(passed_tests/len(test_cases))*100:.2f}%")
        
        # 安全断言
        self.assertEqual(passed_tests, len(test_cases))  # 所有测试都应通过


class TestErrorHandlingSecurity(unittest.TestCase):
    """错误处理安全测试"""
    
    def test_information_leakage_prevention(self):
        """测试信息泄露防护"""
        def safe_error_handler(operation):
            """安全的错误处理器"""
            try:
                # 模拟可能失败的操作
                if operation == "divide_by_zero":
                    result = 1 / 0
                elif operation == "file_not_found":
                    with open("nonexistent_file.txt", "r") as f:
                        content = f.read()
                elif operation == "database_error":
                    raise DatabaseError("Connection failed: 192.168.1.100:5432")
                else:
                    return {"success": True, "result": "操作成功"}
                
                return {"success": True, "result": result}
            
            except ZeroDivisionError:
                # 安全错误信息（不泄露内部细节）
                return {"success": False, "error": "数学运算错误"}
            
            except FileNotFoundError:
                return {"success": False, "error": "文件不存在"}
            
            except DatabaseError as e:
                # 隐藏敏感信息（IP地址、端口等）
                return {"success": False, "error": "数据库连接失败"}
            
            except Exception as e:
                # 通用错误处理
                return {"success": False, "error": "系统错误"}
        
        # 测试错误处理
        test_operations = [
            "divide_by_zero",
            "file_not_found", 
            "database_error",
            "normal_operation"
        ]
        
        sensitive_info_leaked = False
        
        for operation in test_operations:
            result = safe_error_handler(operation)
            
            # 检查是否泄露敏感信息
            error_message = result.get("error", "")
            sensitive_patterns = [
                r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}",  # IP地址
                r":\d+",  # 端口号
                r"password|pwd|secret|key",  # 敏感词汇
                r"stack trace|traceback|line \d+"  # 堆栈信息
            ]
            
            for pattern in sensitive_patterns:
                if re.search(pattern, error_message, re.IGNORECASE):
                    sensitive_info_leaked = True
                    print(f"信息泄露检测: {operation} -> {error_message}")
        
        print(f"\n=== 信息泄露防护测试结果 ===")
        print(f"测试操作: {len(test_operations)}")
        print(f"敏感信息泄露: {'是' if sensitive_info_leaked else '否'}")
        
        # 安全断言
        self.assertFalse(sensitive_info_leaked)  # 不应泄露敏感信息


# 自定义异常类
class SecurityError(Exception):
    """安全异常"""
    pass

class AuthenticationError(Exception):
    """认证异常"""
    pass

class RateLimitError(Exception):
    """限流异常"""
    pass

class ValidationError(Exception):
    """验证异常"""
    pass

class DatabaseError(Exception):
    """数据库异常"""
    pass


if __name__ == "__main__":
    # 运行安全测试
    unittest.main(verbosity=2)