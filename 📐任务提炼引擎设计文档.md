# 📐 任务提炼引擎设计文档

**版本**: V1.0  
**日期**: 2025-11-11  
**优先级**: P0（最高优先级）  
**预计开发时间**: 2天（Day 3-4）

---

## 🎯 需求来源

**用户需求原文**：
> "2）从备忘录中提炼任务到智能工作计划中"

**用户详细说明**：
> "聊天框识别、收集进入备忘录的重要信息...综合分类后给用户确定计划"

**核心目标**：
将备忘录中的信息智能提炼为可执行的工作计划任务

---

## 📊 系统架构

```
┌─────────────────────────────────────────────────────────┐
│                     备忘录系统                           │
│  [任务] [想法] [提醒] [重要信息]                         │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│                  任务提炼引擎                            │
│  ┌──────────┬──────────┬──────────┬──────────┐         │
│  │ AI分析   │ 任务提取 │ 优先级   │ 依赖识别 │         │
│  └──────────┴──────────┴──────────┴──────────┘         │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│                 智能工作计划系统                         │
│  [待办任务] [进行中] [已完成] [归档]                     │
└─────────────────────────────────────────────────────────┘
```

---

## 🏗️ 核心功能模块

### 1. 任务提炼器（Task Extractor）

**功能**: 从备忘录中提取可执行任务

**输入**: 
- 备忘录对象（Memo）
- 上下文信息（可选）

**输出**: 
- 任务列表（List[Task]）

**提炼规则**:

1. **直接任务（置信度高）**
   - 备忘录类型 = task
   - 包含明确动作词（完成、实现、开发、测试）
   - 有明确截止时间
   - 示例：`明天需要完成ERP报表` → `完成ERP报表`

2. **间接任务（需分解）**
   - 备忘录类型 = idea
   - 可能需要多个步骤
   - 示例：`增加用户画像功能` → 
     - `设计用户画像数据模型`
     - `开发用户画像API`
     - `实现用户画像UI`

3. **提醒转任务**
   - 备忘录类型 = reminder
   - 有明确时间点
   - 示例：`下午3点开会` → `参加下午3点会议`

4. **重要信息处理**
   - 备忘录类型 = important
   - 识别是否包含待办事项
   - 示例：`重要：需要更新密码` → `更新系统密码`

---

### 2. 优先级评估器（Priority Evaluator）

**功能**: 智能评估任务优先级

**评估维度**:

1. **紧急度（Urgency）**
   - 有明确截止时间 → 高
   - "今天"、"明天" → 高
   - "本周" → 中
   - "下月" → 低

2. **重要度（Importance）**
   - 标记为"重要" → 高
   - 影响系统核心功能 → 高
   - 用户体验优化 → 中
   - 代码重构 → 低

3. **影响范围（Impact）**
   - 影响多个模块 → 高
   - 影响单个模块 → 中
   - 局部优化 → 低

4. **工作量（Effort）**
   - 小任务（<4小时）→ 可快速完成
   - 中任务（4-16小时）→ 1-2天
   - 大任务（>16小时）→ 需要分解

**优先级矩阵**:

```
        重要且紧急 → P0（立即执行）
        重要不紧急 → P1（计划执行）
        紧急不重要 → P2（委托或快速处理）
        不紧急不重要 → P3（可延后）
```

---

### 3. 依赖关系识别器（Dependency Analyzer）

**功能**: 识别任务之间的依赖关系

**依赖类型**:

1. **顺序依赖（Sequential）**
   - A必须在B之前完成
   - 示例：`设计数据模型` → `开发API` → `实现UI`

2. **并行任务（Parallel）**
   - 可以同时进行
   - 示例：`前端开发` || `后端开发`

3. **阻塞关系（Blocking）**
   - A未完成，B无法开始
   - 示例：`需求评审通过` → `开始开发`

4. **资源依赖（Resource）**
   - 需要同一资源
   - 示例：需要同一开发人员

**识别方法**:

```python
def analyze_dependencies(tasks: List[Task]) -> Dict[str, List[str]]:
    """
    分析任务依赖关系
    
    Returns:
        {
            'task_id_1': ['depends_on_task_id_2', 'depends_on_task_id_3'],
            ...
        }
    """
    dependencies = {}
    
    # 1. 关键词匹配
    keywords = {
        '之后': 'after',
        '之前': 'before',
        '完成后': 'after_complete',
        '需要先': 'prerequisite'
    }
    
    # 2. 语义分析
    # 3. 时间顺序
    # 4. 领域知识（开发流程：设计→开发→测试）
    
    return dependencies
```

---

### 4. 任务分类器（Task Classifier）

**功能**: 将任务分类到合适的类别

**分类维度**:

1. **按类型**
   - 开发任务（Development）
   - 测试任务（Testing）
   - 设计任务（Design）
   - 会议任务（Meeting）
   - 文档任务（Documentation）
   - 运维任务（Operations）

2. **按模块**
   - ERP
   - RAG
   - 备忘录系统
   - 任务系统
   - 前端
   - 后端

3. **按技能**
   - 前端开发
   - 后端开发
   - UI设计
   - 数据库
   - AI/ML

**分类算法**:

```python
class TaskClassifier:
    def __init__(self):
        self.categories = {
            'development': ['开发', '实现', '编码', 'coding', 'dev'],
            'testing': ['测试', 'test', 'bug', '修复', 'fix'],
            'design': ['设计', 'UI', 'UX', '原型', 'design'],
            'meeting': ['会议', '讨论', '评审', 'meeting'],
            'documentation': ['文档', 'doc', '说明', '注释'],
        }
    
    def classify(self, task: Task) -> List[str]:
        """分类任务"""
        categories = []
        
        # 关键词匹配
        for category, keywords in self.categories.items():
            if any(kw in task.content for kw in keywords):
                categories.append(category)
        
        # 标签匹配
        if task.tags:
            categories.extend(task.tags)
        
        return list(set(categories))
```

---

### 5. 任务分解器（Task Decomposer）

**功能**: 将大任务分解为小任务

**分解策略**:

1. **功能分解**
   ```
   "开发用户画像功能"
   → 1. 设计数据模型
   → 2. 实现后端API
   → 3. 开发前端界面
   → 4. 编写测试用例
   → 5. 部署上线
   ```

2. **时间分解**
   ```
   "完成Q4项目"
   → Week 1: 需求分析
   → Week 2: 设计方案
   → Week 3-4: 开发实现
   → Week 5: 测试优化
   ```

3. **模块分解**
   ```
   "重构ERP系统"
   → 订单模块重构
   → 库存模块重构
   → 财务模块重构
   ```

**分解规则**:

```python
class TaskDecomposer:
    def should_decompose(self, task: Task) -> bool:
        """判断是否需要分解"""
        # 1. 预估工作量 > 8小时
        # 2. 包含"和"、"及"等连接词
        # 3. 描述较复杂（>50字）
        return (
            task.estimated_hours > 8 or
            '和' in task.content or
            len(task.content) > 50
        )
    
    def decompose(self, task: Task) -> List[Task]:
        """分解任务"""
        if not self.should_decompose(task):
            return [task]
        
        # AI分解
        prompt = f"""
        将以下任务分解为具体的子任务：
        
        任务：{task.content}
        
        要求：
        1. 每个子任务应该可以在1天内完成
        2. 子任务之间应该有明确的先后顺序
        3. 子任务描述具体、可执行
        
        请以JSON格式返回子任务列表。
        """
        
        subtasks = self.llm.chat(prompt)
        return subtasks
```

---

## 💾 数据模型

### Task（任务）

```python
from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel
from enum import Enum

class TaskStatus(str, Enum):
    """任务状态"""
    TODO = "todo"              # 待办
    IN_PROGRESS = "in_progress"  # 进行中
    BLOCKED = "blocked"        # 阻塞
    REVIEW = "review"          # 评审中
    COMPLETED = "completed"    # 已完成
    CANCELLED = "cancelled"    # 已取消

class TaskPriority(str, Enum):
    """任务优先级"""
    P0 = "p0"  # 最高优先级（紧急且重要）
    P1 = "p1"  # 高优先级（重要不紧急）
    P2 = "p2"  # 中优先级（紧急不重要）
    P3 = "p3"  # 低优先级（不紧急不重要）

class TaskType(str, Enum):
    """任务类型"""
    DEVELOPMENT = "development"
    TESTING = "testing"
    DESIGN = "design"
    MEETING = "meeting"
    DOCUMENTATION = "documentation"
    OPERATIONS = "operations"
    OTHER = "other"

class Task(BaseModel):
    """任务数据模型"""
    id: str
    
    # 基础信息
    title: str                          # 任务标题
    description: Optional[str] = None   # 任务描述
    content: str                        # 任务内容（从备忘录提取）
    
    # 分类和优先级
    type: TaskType = TaskType.OTHER
    priority: TaskPriority = TaskPriority.P2
    categories: List[str] = []          # 分类标签
    tags: List[str] = []
    
    # 状态和进度
    status: TaskStatus = TaskStatus.TODO
    progress: int = 0                   # 进度百分比 0-100
    
    # 时间信息
    created_at: datetime
    updated_at: datetime
    due_date: Optional[datetime] = None
    start_date: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    
    # 工作量估算
    estimated_hours: Optional[float] = None
    actual_hours: Optional[float] = None
    
    # 关联信息
    source_memo_id: Optional[str] = None  # 来源备忘录ID
    parent_task_id: Optional[str] = None  # 父任务ID（如果是子任务）
    subtasks: List[str] = []              # 子任务ID列表
    depends_on: List[str] = []            # 依赖的任务ID列表
    
    # 分配信息
    assignee: Optional[str] = None        # 负责人
    user_id: str                          # 所属用户
    
    # AI提炼信息
    extraction_confidence: float = 1.0    # 提炼置信度
    extraction_method: str = "manual"     # 提炼方法：manual/rule/ai
    
    # 附加信息
    notes: Optional[str] = None
    attachments: List[str] = []
    links: List[str] = []
```

---

## 🔄 工作流程

### 主流程：从备忘录到任务

```
用户创建备忘录
    ↓
备忘录保存到数据库
    ↓
触发任务提炼
    ↓
[1] 任务提炼器分析备忘录
    - 判断是否可以提炼为任务
    - 提取任务信息
    ↓
[2] 优先级评估器评估优先级
    - 紧急度分析
    - 重要度分析
    - 综合评分
    ↓
[3] 任务分类器分类
    - 按类型分类
    - 按模块分类
    - 按技能分类
    ↓
[4] 任务分解器（如果需要）
    - 判断是否需要分解
    - 分解为子任务
    - 建立父子关系
    ↓
[5] 依赖识别器识别依赖
    - 分析任务之间的依赖
    - 建立依赖关系图
    ↓
创建任务
    ↓
通知用户确认
    ↓
用户确认或调整
    ↓
添加到工作计划
```

---

## 📡 API设计

### 任务提炼API

```python
# 1. 从备忘录提炼任务
POST /api/v1/tasks/extract-from-memo
{
    "memo_id": "memo_123",
    "auto_create": false,  # 是否自动创建任务
    "user_id": "user_123"
}

Response:
{
    "extracted_tasks": [
        {
            "title": "完成ERP报表功能",
            "priority": "p0",
            "due_date": "2025-11-12",
            "confidence": 0.95,
            "subtasks": []
        }
    ],
    "needs_confirmation": true
}

# 2. 批量提炼任务
POST /api/v1/tasks/batch-extract
{
    "memo_ids": ["memo_1", "memo_2", "memo_3"],
    "user_id": "user_123"
}

# 3. 智能建议任务
GET /api/v1/tasks/suggestions
?user_id=user_123&limit=10

# 4. 分析任务依赖
POST /api/v1/tasks/analyze-dependencies
{
    "task_ids": ["task_1", "task_2", "task_3"]
}
```

### 任务管理API

```python
# 5. 创建任务
POST /api/v1/tasks/
{
    "title": "任务标题",
    "content": "任务内容",
    "priority": "p1",
    "type": "development",
    "due_date": "2025-11-15",
    "user_id": "user_123"
}

# 6. 获取任务列表
GET /api/v1/tasks/
?user_id=user_123&status=todo&priority=p0

# 7. 更新任务
PUT /api/v1/tasks/{task_id}

# 8. 删除任务
DELETE /api/v1/tasks/{task_id}

# 9. 更新任务状态
PATCH /api/v1/tasks/{task_id}/status
{
    "status": "in_progress"
}

# 10. 更新任务进度
PATCH /api/v1/tasks/{task_id}/progress
{
    "progress": 50
}
```

---

## 🧠 AI提炼算法

### 提炼策略

**1. 规则基础提炼（Rule-Based）**
- 快速、不依赖LLM
- 基于关键词和模式匹配
- 适合明确的任务描述

**2. AI增强提炼（AI-Enhanced）**
- 使用LLM理解语义
- 处理复杂、模糊的描述
- 可以分解和细化任务

**3. 混合提炼（Hybrid）**
- 先用规则快速判断
- 复杂情况用AI增强
- 平衡速度和准确度

### 提炼算法

```python
class TaskExtractor:
    def extract(self, memo: Memo) -> List[Task]:
        """从备忘录提炼任务"""
        
        # Step 1: 快速判断是否包含任务
        if not self.contains_task(memo):
            return []
        
        # Step 2: 规则提炼
        rule_tasks = self.rule_based_extract(memo)
        
        # Step 3: 如果规则提炼置信度低，使用AI
        if rule_tasks and rule_tasks[0].extraction_confidence < 0.7:
            ai_tasks = self.ai_enhanced_extract(memo)
            # 合并结果
            tasks = self.merge_extractions(rule_tasks, ai_tasks)
        else:
            tasks = rule_tasks
        
        # Step 4: 优先级评估
        for task in tasks:
            task.priority = self.evaluate_priority(task, memo)
        
        # Step 5: 分类
        for task in tasks:
            task.categories = self.classify_task(task)
        
        # Step 6: 判断是否需要分解
        final_tasks = []
        for task in tasks:
            if self.should_decompose(task):
                subtasks = self.decompose_task(task)
                final_tasks.extend(subtasks)
            else:
                final_tasks.append(task)
        
        return final_tasks
    
    def contains_task(self, memo: Memo) -> bool:
        """判断备忘录是否包含任务"""
        # 1. 类型检查
        if memo.type in [MemoType.TASK, MemoType.REMINDER]:
            return True
        
        # 2. 关键词检查
        task_keywords = ['需要', '完成', '做', '实现', '开发', '测试']
        if any(kw in memo.content for kw in task_keywords):
            return True
        
        return False
```

---

## 📊 用户交互

### 任务确认流程

```
AI提炼出任务
    ↓
显示确认界面
┌──────────────────────────────────┐
│ 🤖 从备忘录中发现以下任务：       │
│                                  │
│ ✓ 完成ERP报表功能                │
│   优先级: 🔴 P0                  │
│   截止: 明天                     │
│   类型: 开发                     │
│                                  │
│ ✓ 编写测试用例                   │
│   优先级: 🟡 P1                  │
│   类型: 测试                     │
│                                  │
│ [✓ 全部确认] [✏️ 编辑] [✕ 取消] │
└──────────────────────────────────┘
    ↓
用户确认
    ↓
添加到工作计划
```

---

## ⚡ 性能优化

1. **批量处理**: 批量提炼多个备忘录
2. **缓存**: 缓存提炼结果
3. **异步处理**: 后台异步提炼
4. **增量更新**: 只处理新增/修改的备忘录

---

## 📈 评估指标

1. **提炼准确率**: 正确提炼的任务数 / 总任务数
2. **提炼召回率**: 成功提炼的任务数 / 应该提炼的任务数
3. **用户接受率**: 用户确认的任务数 / AI提炼的任务数
4. **处理速度**: 平均提炼时间

---

## 🎯 Day 3 开发计划

### 上午（4小时）
- ✅ 设计文档完成
- ⏰ 数据模型实现
- ⏰ 任务提炼器（规则基础）

### 下午（4小时）
- ⏰ 优先级评估器
- ⏰ 任务分类器
- ⏰ API接口实现

### 预期输出
- Task数据模型
- TaskExtractor类
- PriorityEvaluator类
- TaskClassifier类
- 10+个API接口

---

*设计文档 V1.0*  
*2025-11-11*




